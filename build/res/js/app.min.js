angular.module('dogfeed', [
    'ngFeeds',
    'ngSockethubClient',
    'ngSockethubRemoteStorage',
    'ngRemoteStorage',
    'ngMessages',
    'ngRoute'
]).

/**
 * routes
 */
config(['$routeProvider', '$locationProvider',
function ($routeProvider, $locationProvider) {
  $locationProvider.html5Mode(true);
  $routeProvider.
    when('/', {
      templateUrl: "/res/views/main.html"
    }).
    when('/settings/sockethub', {
      templateUrl: "sockethub-settings.html"
    }).
    when('/feeds/add', {
      templateUrl: '/res/js/feeds/feed-add.html.tpl'
    }).
    when('/feeds/edit/:feed', {
      templateUrl: '/res/js/feeds/feed-edit.html.tpl'
    }).
    when('/feeds/:feed', {
      templateUrl: '/res/views/articles.html'
    }).
    when('/about', {
      templateUrl: 'about.html'
    }).
    otherwise({
      redirectTo: "/"
    });
}]).

run(['$rootScope', '$timeout',
function ($rootScope, $timeout) {
  $rootScope.delayed = false;
  $timeout(function () {
    // give the app a second or two to load before we determine if the user
    // is logged in or not.
    $rootScope.delayed = true;
  }, 3000);
}]).

run([function () {
  // TODO
  // this should be executed when we know the appropriate dom elements are
  // loaded.
  // right now if someone *starts* on the settings page, this will be executed
  // and wont bind to anything as the contacts view was not registered.
  setTimeout(function () {
    $(document).ready(function() {
      $('[data-toggle=offcanvas]').click(function() {
        if ($('.opposite-sidebar').hasClass('slider-active')) {
          $('.opposite-sidebar').removeClass('slider-active');
          $('#remotestorage-widget').removeClass('hidden');
        } else {
          $('.opposite-sidebar').addClass('slider-active');
          $('#remotestorage-widget').addClass('hidden');
        }
      });

      // always close slider when navigation happens
      $('.main-link').click(function() {
        console.log('---- HELLO!!');
        $('.opposite-sidebar').removeClass('slider-active');
        $('#remotestorage-widget').removeClass('hidden');
      });
      $("[name='showRead']").bootstrapSwitch('size', 'small');
    });
  }, 500);
}]).


/**
 * remotestorage config
 */
run(['RemoteStorageConfig',
function (RScfg) {
  RScfg.modules = [
    ['sockethub', 'rw', {'cache': true, 'public': false}],
    ['feeds', 'rw', {'cache': true, 'public': false}],
    ['articles', 'rw', {'cache': true, 'public': false}]
  ];
}]).

/**
 * messages config
 */
run(['MessagesConfig',
function (cfg) {
  //cfg.timeout = 15000;
}]).

/**
 * get sockethub settings and try to connect
 */
run(['SockethubBootstrap',
function (SockethubBootstrap) {
  SockethubBootstrap.run('dogfeed', {
    // default connection settings, if none found in remoteStorage
    host: 'silverbucket.net',
    port: '443',
    path: '/sockethub',
    tls: true,
    secret: '1234567890'
  });
}]).

/**
 * remoteStorage
 */
run(['$rootScope', 'RS', '$timeout',
function ($rootScope, RS, $timeout) {
  // set custom messages
  var dict = RemoteStorage.I18n.getDictionary();
  dict.view_connect = "<strong>Login</strong>";
  RemoteStorage.I18n.setDictionary(dict);

  // check if connected
  if (!RS.isConnected()) {
    $timeout(function () {
      if (!RS.isConnected()) {
        $rootScope.$broadcast('message', {message: 'remotestorage-connect', timeout: false});
      }
    }, 3000);
  }
}]).

/**
 * listeners/emitters
 */
run(['$rootScope', '$location',
function ($rootScope, $location) {
  $rootScope.$on('sockethubSettingsSaved', function() {
    $location.path('/');
  });
}]).

/**
 * filter: fromNow (date)
 */
filter('fromNow', [
function() {
  return function (dateString) {
    return new Date(dateString).toDateString(); ///moment(new Date(dateString)).fromNow();
  };
}]).

/**
 * filter: pagination
 */
filter('pagination', [
function() {
  var count = 0;
  var max = 3;
  return function (article) {
    console.log("pagination received: ", article);
    if (!article) { return false; }
    count = count + 1;
    if (count > 10) {
      console.log('pagination returned false');
      return false;
    }
    console.log('pagination returned article: ',article);
    return article;
  };
}]).

///////////////////////////////////////////////////////////////////////////
//
// CONTROLLERS
//
///////////////////////////////////////////////////////////////////////////

/**
 * controller: titlebarCtrl
 */
controller('titlebarCtrl',
['$scope', '$rootScope', 'SockethubSettings', 'RS',
function ($scope, $rootScope, settings, RS) {

  $scope.showFeedList = function () {
    if ($rootScope.snapper.state().state === "left") {
      $rootScope.snapper.close();
    } else {
      $rootScope.snapper.open('left');
    }
  };

  $scope.$watch('settings.connected', function (newVal, oldVal) {
    if (settings.connected) {
      settings.conn.port = Number(settings.conn.port);
      RS.call('sockethub', 'writeConfig', ['dogfeed', settings.conn]).then(function () {
        console.log("Sockethub config saved to remoteStorage");
      }, function (err) {
        console.log('Failed saving Sockethub config to remoteStorage: ', err);
      });
    }
  });
}]).

controller('mainCtrl', ['$scope', 'RS', 'SH', '$timeout', '$rootScope', '$routeParams', 'Feeds',
function ($scope, RS, SH, $timeout, $rootScope, $routeParams, Feeds) {
  //console.log("mainCtrl ROUTE PARAMS: ", $routeParams);
  $scope.isConnected = function () {
    //console.log('isConnected: ['+RS.isConnected()+'] ['+SH.isConnected()+'] ['+$routeParams.feed+']');
    if ((RS.isConnected()) && (SH.isConnected())) {
      return true;
    } else {
      if ((($routeParams.feed) || (Feeds.data.articles.length > 0)) && (SH.isConnected())) {
        return true;
      } else {
        return false;
      }
    }
  };

  $scope.isConnecting = function () {
    //console.log('isConnecting: ['+RS.isConnected()+'] ['+SH.isConnected()+']');
    if ((RS.isConnecting()) || (SH.isConnecting())) {
      return true;
    } else {
      return false;
    }
  };

  $scope.delayed = function () {
    return $rootScope.delayed;
  };

  $scope.waitingForArticles = function () {
    if ((Feeds.data.articles.length <= 1) &&
        (Feeds.data.infoArray > 0)) {
      return true;
    } else {
      return false;
    }
  };

  $scope.haveArticles = function () {
    if (Feeds.data.articles.length > 0) {
      return true;
    } else {
      return false;
    }
  };

  $scope.noFeeds = function () {
    if ((Feeds.data.infoArray.length === 0) &&
        (Feeds.data.state.remoteStorage)) {
      return true;
    } else {
      return false;
    }
  };

}]).

directive('loading', [
function () {
  return {
    restrict: 'E',
    templateUrl: 'loading.html'
  };
}]).

directive('welcome', [
function () {
  return {
    restrict: 'E',
    templateUrl: 'welcome.html'
  };
}]).

directive('about', [
function () {
  return {
    restrict: 'E',
    templateUrl: 'about.html'
  };
}]);
;angular.module('ngFeeds', ['ngRemoteStorage', 'ngSockethubClient', 'ngSanitize']).


/**
 * settings service
 */
value('configHelper', {
  exists: function exists(config, cfg) {
    if (!cfg) {
      cfg = config;
    }

    for (var key in config) {
      if (!cfg[key]) {
        return false;
      }
    }
    return true;
  },
  set: function (config, cfg) {
    for (var key in cfg) {
      config[key] = cfg[key];
    }
    return config;
  }
}).

run(['$routeParams', '$rootScope', 'Feeds',
function ($routeParams, $rootScope, Feeds) {

  $rootScope.feeds = Feeds.data;

}]).


///////////////////////////////////////////////////////////////////////////
//
// FACTORY
//
///////////////////////////////////////////////////////////////////////////

/**
 * Factory: Feeds
 */
factory('Feeds', ['$q', 'SH', 'configHelper', 'RS', '$rootScope', '$sce',
function ($q, SH, CH, RS, $rootScope, $sce) {

  var config = {};
  var data = {
    articles: [],
    info: {},
    infoArray: [],
    groups: {},
    groupArray: [],
    settings: {
      showRead: true,  // show read articles or disappear them
      articlesPerPage: 5,  // number of articles to show per page
      displayCap: 10,  // current limit of articles to show (increments by articlesPerPage)
      displayed: {}  // index of displayed articles
    },
    current: {
      name: '',
      indexes: []
    },
    edit: {
      name: '',
      url: '',
      origName: ''
    },
    state: {
      remoteStorage: false
    }
  };
  var func = {};

  function trustMedia (o) {
    // 'trust' media urls
    if (typeof o.object.media === 'object') {
      for (var i = 0, len = o.object.media.length; i < len; i = i + 1) {
        o.object.media[i].url = $sce.trustAsResourceUrl(o.object.media[i].url);
      }
    }
  }

  /****
   * CONFIG MANAGEMENT
   ********************/
  function exists(cfg) {
    return CH.exists(config, cfg);
  }

  func.setConfig = function set(cfg) {
    var defer = $q.defer();
    if (exists(cfg)) {
      if (cfg) {
        CH.set(config, cfg);
      }
      defer.resolve(config);
    } else {
      defer.reject('config not set correctly');
    }
    return defer.promise;
  };

  /****
   * ARTICLE MANAGEMENT
   *********************/
  // update or create an article entry
  // - add to article indexes
  // - update on remoteStorage
  func.updateArticle = function updateArticle(obj) {
    var defer = $q.defer();
    var s_obj = {
      link: obj.object.link,
      title: obj.object.title,
      date: obj.object.date,
      datenum: Date.parse(obj.object.date) || 0,
      html: obj.object.html,
      text: obj.object.text,
      brief_html: obj.object.brief_html,
      brief_text: obj.object.brief_text,
      read: (obj.object.read) ? true : false,
      source_link: obj.actor.address,
      source_title: obj.actor.name
    };

    RS.call('articles', 'update', [s_obj]).then(function (m) {
      //console.log('article added: ', m);
      //data.info[obj.url] = obj;
      //func.fetchFeed(obj.url);
      defer.resolve(m);
    }, function (err) {
      defer.reject(err);
    });
    return defer.promise;
  };

  /****
   * FEED MANAGEMENT
   ******************/
  // grab whatever feeds exists in remoteStorage right away
  (function getFeedUrls() {
    setTimeout(function () {
      $rootScope.$broadcast('message', {
        message: 'fetching feeds from remoteStorage',
        title: 'Info',
        type: 'info',
        timeout: false
      });
    }, 1000);
    RS.call('feeds', 'getAll', ['']).then(function (feeds) {
      console.log('Feeds: got feed urls from remoteStorage ', feeds);
      for (var key in feeds) {
        if ((!feeds[key]) || ((typeof feeds[key].url === 'undefined') &&
                             (typeof feeds[key].address === 'undefined'))) {
          console.log('ERROR processing url['+key+']: ', feeds[key]);
        } else {
          feeds[key].url = (feeds[key].url) ? feeds[key].url : feeds[key].address;
          feeds[key].unread = 0;
          func.updateFeed(feeds[key]);
          func.fetchFeed(feeds[key].url); // asign existing feed info to data struct
        }
      }
      data.state.remoteStorage = true;
    }, function (err) {
      console.log('error: unable to get feed list from remoteStorage: ', err);
      $rootScope.$broadcast('message', {
        message: 'unable to get feed list from remotestorage',
        type: 'error',
        timeout: false
      });
      data.state.remoteStorage = true;
    });
  })();

  /**
   * Function: _saveFeed
   *
   * take a feed object, add to info & infoArray and queue to
   * store to remoteStorage.
   *
   * Parameters:
   *
   *   obj - feed object
   *
   */
  function _saveFeed (obj) {
    //console.log('********** ADDING:', obj);
    data.info[obj.url] = obj;
    _addToInfoArray(obj);
    RS.queue('feeds', 'add', [obj]);
  }

  //
  // find if object already exists in infoArray, if so overwrite with new object
  // else push it to stack.
  //
  function _addToInfoArray(obj) {
    // iterate through infoArray to see if this feed entry exists in it already
    var updated = false;
    for (var i = 0, len = data.infoArray.length; i < len; i = i + 1) {
      if ((data.infoArray[i]) && (data.infoArray[i].url === obj.url)) {
        data.infoArray[i] = obj;
        updated = true;
        break;
      }
    }
    if (!updated) {
      data.infoArray.push(obj);
    }
  }

  /**
   * Function: updateFeed
   *
   * update feed with the passed in feed object
   *
   * Parameters:
   *
   *   obj - feed object (remotestorage or sockethub format)
   */
  func.updateFeed = function (obj) {
    console.log('updateFeed called', obj);
    var updated = false;
    var defaults = {
      name: '',
      cache_articles: 20,
      last_fetched: new Date().getTime(),
      unread: 0,
      image: '',
      favicon: ''
    };

    if (data.info[obj.url]) {
      // feed record exists, update it. set defaults based on existing record.
      defaults.name = (data.info[obj.url].name) ? data.info[obj.url].name : defaults.name;
      defaults.cache_articles = (data.info[obj.url].cache_articles) ? data.info[obj.url].cache_articles : defaults.cache_articles;
      defaults.last_fetched = (data.info[obj.url].last_fetched) ? data.info[obj.url].last_fetched : defaults.last_fetched;
      defaults.unread = (data.info[obj.url].unread) ? data.info[obj.url].unread : defaults.unread;
      defaults.image = (data.info[obj.url].image) ? data.info[obj.url].image : defaults.image;
      defaults.favicon = (data.info[obj.url].favicon) ? data.info[obj.url].favicon : defaults.favicon;
    }

    // now ensure passed in object has all fields updated, assuming passed in object
    // is the most recent copy we have to go on.
    obj.url = (obj.address) ? obj.address : obj.url;
    obj.cache_articles = (obj.cache_articles) ? obj.cache_articles : defaults.cache_articles;
    obj.last_fetched = (obj.last_fetched) ? obj.last_fetched : defaults.last_fetched;
    obj.unread = (obj.unread) ? obj.unread : ((data.info[obj.url]) &&
                                              (data.info[obj.url].unread)) ? data.info[obj.url].unread : defaults.unread;
    obj.image = (typeof obj.image === 'object' && typeof obj.image.url === 'string') ? obj.image.url : defaults.image;
    obj.favicon = (obj.favicon) ? obj.favicon : defaults.favicon;

    // remotestorage doesn't use these properties, but sockethub passes them to us
    // so let's delete them now.
    delete obj.objectType;
    delete obj.categories;
    delete obj.address;

    _saveFeed(obj);
  };

  /**
   * Function: removeFeed
   *
   * remove a feed from the feed lists and remotestorage
   *
   * Parameters:
   *
   *   url - feed url
   */
  func.removeFeed = function (url) {
    var defer = $q.defer();

    RS.call('feeds', 'remove', [url]).then(function (m) {
      defer.resolve(m);
    }, function (err) {
      defer.reject(err);
    });

    delete data.info[url];
    // remove this feed from infoArray
    for (var i = 0, len = data.infoArray.length; i < len; i = i + 1) {
      if ((data.infoArray[i]) && (data.infoArray[i].url === url)) {
        data.infoArray.splice(i, 1);
        break;
      }
    }
    // remove articles for this feed
    for (i = 0, len = data.articles.length; i < len; i = i + 1) {
      if ((data.articles[i]) && (data.articles[i].actor.address === url)) {
        data.articles.splice(i, 1);
      }
    }
    console.log('articles count: '+data.articles.length);
    console.log('feed removed: ', url);

    return defer.promise;
  };

  /****
   * FEED FETCHING
   ****************/
  // issue orders to fetch feeds from sockethub
  func.fetchFeed = function fetch(url, date) {

    var msg = {
      verb: 'fetch',
      platform: 'feeds',
      actor: {
        address: 'feeds'
      },
      target: [{
        address: url
      }],
      object: {
        limit: data.settings.articlesPerPage,
        date: date || 0,
        from: 'before'
      }
    };

    var defer = $q.defer();
    var name = url;
    if (typeof data.info[url] !== 'undefined') {
      name = data.info[url].name;
      data.info[url].loaded = false;
    }
    $rootScope.$broadcast('message', {type: 'info', message: 'fetching articles from '+name});

    SH.submit.call(msg).then(function (o) {
      $rootScope.$broadcast('message', {type: 'success', title: 'Fetched', message: ''+name});
      data.info[url].loaded = true;
      defer.resolve();
    }, function (e) {
      console.log('failed fetch '+url, data.info);
      if (typeof data.info[url] === 'object') {
        data.info[url].loaded = true;
        data.info[url].error = e;
      }
      $rootScope.$broadcast('message', {
        message: 'failed fetching feed: '+url+': '+e,
        type: 'error'
      });
      defer.reject(e);
    });
    return defer.promise;
  };

  //
  // detect when new articles are received from Sockethub
  //
  SH.on('feeds', 'message', function (m) {
    //console.log("Feeds received message ",m);
    var key = m.actor.address;

    if (!m.status) {
      console.log('received error message from sockethub: ', m);
      $rootScope.$broadcast('message', {
        type: 'error',
        message: m.target[0].address + ' ' + m.message
      });
      return;
    }

    //
    // check if the feed entry for this article exists yet, if not add it.
    // also check to update name.
    //
    if (!data.info[key])  {
      func.updateFeed(m.actor);
    } else if ((!data.info[key].name) || (data.info[key].name === data.info[key].url)) {
      func.updateFeed(m.actor);
    } else if ((typeof m.actor.image === 'object' && typeof m.actor.image.url === 'string') && (data.info[key].image !== m.actor.image.url)) {
      func.updateFeed(m.actor);
    }

    if (!m.object.read) {
      m.object.read = false;
      data.info[key].unread = (typeof data.info[key].unread === "number") ? data.info[key].unread + 1 : 1;
    }

    if (!m.object.datenum) {
      m.object.datenum = Date.parse(m.object.date) || 0;
    }

    if (data.info[key].oldestFetched > m.object.datenum) {
      data.info[key].oldestFetched = m.object.datenum;
    }

    // clean urls for angularjs security
    trustMedia(m);

    // add article to article list
    data.articles.push(m);

    //
    // we've added the article from sockethub to the article list, now let's
    // try to fetch the article from remoteStorage to see we already have a
    // record of it.
    //
    // if so, we apply read status.
    //
    RS.call('articles', 'getByUrl', [m.object.link]).then(function (a) {
      if ((typeof a === 'object') && (typeof a.read === 'boolean')) {
        //console.log('ARTICLE FETCH from RS: ', a);
        m.object.read = (a.read) ? a.read : false;

        if (m.object.read) {
          // this article is read, subtract from total
          data.info[key].unread = (typeof data.info[key].unread === "number") ? data.info[key].unread - 1 : 0;
        }
      }
    }, function (e) {
      console.log("ARTICLE FETCH ERROR: ", e);
    });
  });

  return {
    config: config,
    data: data,
    func: func
  };
}]).


///////////////////////////////////////////////////////////////////////////
//
// CONTROLLERS
//
///////////////////////////////////////////////////////////////////////////

/**
 * controller: addFeedCtrl
 */
controller('addFeedCtrl',
['$scope', 'Feeds', '$location',
function ($scope, Feeds, $location) {
  $scope.adding = false;

  $scope.add = function (url) {
    $scope.adding = true;
    Feeds.func.fetchFeed(url).then(function () {
      $scope.adding = false;
      $location.path('/feed/'+url);
    }, function (e) {
      $scope.adding = false;
    });
  };

}]).

/**
 * controller: feedSettingsCtrl
 */
controller('feedSettingsCtrl',
['$scope', 'Feeds', '$rootScope', '$routeParams', '$location',
function ($scope, Feeds, $rootScope, $routeParams, $location) {
  $scope.saving = false;
  $scope.feeds = Feeds.data;
  var feedUrl;
  if ($routeParams.feed) {
    feedUrl = decodeURIComponent($routeParams.feed);
    console.log('feedSettingsCtrl feedUrl: '+feedUrl, Feeds.data.info);
    Feeds.data.edit.url = feedUrl;
    Feeds.data.edit.name = Feeds.data.info[feedUrl].name;
    Feeds.data.edit.origName = Feeds.data.info[feedUrl].name;
  } else {
    $location.path('/feeds/');
  }

  $scope.saveFeedSettings = function (feed) {
    $scope.saving = true;
    console.log('saveFeed', feed);
    delete feed.origName;
    Feeds.func.updateFeed(feed);
    $scope.saving = false;
    $location.path('/feeds/'+feedUrl);
  };

  $scope.cancelFeedSettings = function () {
    console.log('CANCEL: '+feedUrl, $scope.feeds.edit);
    Feeds.data.info[feedUrl].name = Feeds.data.edit.origName;
    $scope.saving = false;
    $location.path('/feeds/'+$routeParams.feed);
  };

  $scope.deleteFeed = function (feed) {
    $scope.saving = true;
    Feeds.func.removeFeed(feed.url).then(function () {
      $rootScope.$broadcast('message', {type: 'success', message: 'deleted feed '+feed.url});
      $scope.saving = false;
      $location.path('/feeds/');
    }, function (err) {
      console.log('error removing feed!: ', err);
      $rootScope.$broadcast('message', {type: 'error', message: err.message});
      $scope.saving = false;
      $location.path('/feeds/');
    });
  };

}]).

/**
 * controller: feedCtrl
 */
controller('feedCtrl',
['$scope', 'Feeds', '$rootScope', '$timeout', '$routeParams',
function ($scope, Feeds, $rootScope, $timeout, $routeParams) {
  //console.log('--- feedCtrl ' + $routeParams.feed);
  $scope.saving = false;

  if ($routeParams.feed) {
    var feed = decodeURIComponent($routeParams.feed);
    //console.log("FEED PARAM: "+feed);
    // if we have a url as a param, we try to fetch it

    //Feeds.data.selectedFeed = feed;
    Feeds.data.current.name = (Feeds.data.info[feed]) ? Feeds.data.info[feed].name : feed;
    Feeds.data.current.id = feed;
    Feeds.data.current.indexes = [feed];
    if (!Feeds.data.info[feed]) {
      $rootScope.$broadcast('message', {
        message: 'attempting to fetch feed from '+feed,
        type: 'info'
      });
      Feeds.func.fetchFeed(feed);
    }
  } else {
    Feeds.data.current.name = '';
    Feeds.data.current.indexes.length = 0;
  }

  $rootScope.$on('SockethubConnectFailed', function (event, e) {
    console.log('Sockethub connect failed! ', e);
    $rootScope.$broadcast('message', {
      message: e.message,
      type: 'error',
      timeout: false
    });
    //$scope.model.loading = true;
    $rootScope.$broadcast('showModalSockethubSettings', {locked: false});
  });
}]).


///////////////////////////////////////////////////////////////////////////
//
// DIRECTIVES
//
///////////////////////////////////////////////////////////////////////////

factory('isSelected', ['Feeds',
function (Feeds) {
  return function (url, inclusive) {
    if (Feeds.data.current.indexes.length === 0) {
      if ((inclusive) || (!url)) {
        return true;
      } else {
        return false;
      }
    } else {
      for (var i = 0, num = Feeds.data.current.indexes.length; i < num; i = i + 1) {
        if (Feeds.data.current.indexes[i] === url) {
          return true;
        }
      }
    }
    return false;
  };
}]).

/**
 * directive: feedList
 */
directive('feedList', ['isSelected', 'Feeds', '$location', '$rootScope',
function (isSelected, Feeds, $location, $rootScope) {
  function FeedListCtrl ($scope) {

    $scope.isSelected = isSelected;

    $scope.switchFeed = function (url, groupId, error) {
      //console.log('SWITCH FEED: '+encodeURIComponent(url));
      if (error) { return false; }
      // ensure slider is closed
      $('.opposite-sidebar').removeClass('slider-active');
      $('#remotestorage-widget').removeClass('hidden');
      if (!url) {
        $location.path('/feeds/');
      } else {
        $location.path('/feeds/'+encodeURIComponent(url));
      }
    };
  }

  return {
    restrict: 'E',
    scope: {
      'feeds': '=',
      'settings': '=',
      'test': '='
    },
    templateUrl: '/res/js/feeds/feed-list.html.tpl',
    controller: FeedListCtrl,
    transclude: true
  };
}]).

/**
 * directive: feedTiles
 */
directive('feedTiles', ['isSelected', 'Feeds', '$location', '$rootScope',
function (isSelected, Feeds, $location, $rootScope) {
  function FeedTilesCtrl ($scope) {

    console.log('******** DATA: ', $scope.feeds);
    $scope.isSelected = isSelected;

    $scope.switchFeed = function (url, groupId, error) {
      //console.log('SWITCH FEED: '+encodeURIComponent(url));
      if (error) { return false; }
      // ensure slider is closed
      $('.opposite-sidebar').removeClass('slider-active');
      $('#remotestorage-widget').removeClass('hidden');
      if (!url) {
        $location.path('/feeds/');
      } else {
        $location.path('/feeds/'+encodeURIComponent(url));
      }
    };
  }

  return {
    restrict: 'E',
    scope: {
      'feeds': '=',
      'settings': '=',
      'test': '='
    },
    templateUrl: '/res/js/feeds/feed-tiles.html.tpl',
    controller: FeedTilesCtrl
  };
}]).


/**
 * directive: articles
 */
directive('articles', ['isSelected', 'Feeds', '$location',
function (isSelected, Feeds, $location) {

  function ArticlesCtrl($scope) {

    $scope.ArticlesDisplayed = {
      oldest: 0
    };

    $scope.feeds = Feeds.data;
    $scope.articlesShown = false;

    $scope.showFeedSettings = function (url) {
      console.log('showFeedSettings: '+url);
      if (!url) {
        return;
      } else {
        $location.path('/feeds/edit/'+encodeURIComponent(url));
      }
    };

    // returns true if current selection is empty (has no unread articles)
    $scope.currentIsEmpty = function () {
      if (!$scope.feeds.current.name) {
        return false;
      }
      for (var i = 0, num = $scope.feeds.current.indexes.length; i < num; i = i + 1) {
        //console.log('checking '+$scope.model.feeds.current.indexes[i], $scope.model.feeds.info[$scope.model.feeds.current.indexes[i]]);
        if ((Feeds.data.info[Feeds.data.current.indexes[i]]) &&
            (Feeds.data.info[Feeds.data.current.indexes[i]].unread > 0)) {
          return false;
        }
        if (Feeds.data.settings.showRead) {
          return false;
        }
      }
      return true;
    };

    /**
     * Function: toggleRead
     *
     * toggle an article as read/unread, update unread could on info index,
     * update article on remoteStorage.
     *
     *
     * Parameters:
     *
     *   a   - article object
     *   idx - index number assigned during angularJS iteration
     *
     * Returns:
     *
     *   return description
     */
    $scope.toggleRead = function (a, idx) {
      //console.log('markRead Called!',idx);
      if (!a.object.read) {
        //console.log('subtracting 1 from : '+ Feeds.data.info[a.actor.address].unread);
        Feeds.data.info[a.actor.address].unread =
            Feeds.data.info[a.actor.address].unread - 1;
        a.object.read = true;
        if ((typeof idx === 'number') &&
            ($('#article'+idx).hasClass('in'))) {
          $('#article'+idx).collapse('hide');
        }
      } else if (a.object.read) {
        //console.log('adding 1 to : '+ Feeds.data.info[a.actor.address].unread);
        Feeds.data.info[a.actor.address].unread =
            Feeds.data.info[a.actor.address].unread + 1;
        a.object.read = false;
      }

      Feeds.func.updateArticle(a);
    };

    /**
     * Function: showMore
     *
     * fetches another group of articles from Sockethub
     *
     */
    $scope.showMore = function () {
      Feeds.data.settings.displayCap = Feeds.data.settings.displayCap +
                                       Feeds.data.settings.articlesPerPage;
      for (var i = 0, num = Feeds.data.current.indexes.length; i < num; i = i + 1) {
        Feeds.func.fetchFeed(Feeds.data.current.indexes[i],
                             $scope.ArticlesDisplayed.oldest);
      }
    };

    /**
     * Function: isShowable
     *
     * returns true/false if the article qualifies for being shown currently.
     * this is based on how many articles can be shown per-page [displayCap]
     * and the number of articles currently being shown [ArticlesDisplayed].
     * Also whether the setting to show read articles is set [showRead].
     *
     * Parameters:
     *
     *   article - article object
     *
     * Returns:
     *
     *   return boolean
     */
    $scope.isShowable = function (article) {
      if (!isSelected(article.actor.address, true)) {
        return false;
      }

      // if (Feeds.data.settings.displayed[article.object.link]) {
      //   return true;
      // }

      if (Object.keys($scope.ArticlesDisplayed).length >= Feeds.data.settings.displayCap) {
        if ((article.object.read) && (!Feeds.data.settings.showRead)) {
          delete $scope.ArticlesDisplayed[article.object.link];
          return false;
        } else if ($scope.ArticlesDisplayed[article.object.link]) {
          $scope.articlesShown = true;
          return true;
        } else {
          delete $scope.ArticlesDisplayed[article.object.link];
          return false;
        }
      }

      if (article.object.read) {
        if (Feeds.data.settings.showRead) {
          $scope.ArticlesDisplayed[article.object.link] = true;
          // keep the oldest value (dateNum of oldest article in list) up to date
          $scope.ArticlesDisplayed.oldest =
              ($scope.ArticlesDisplayed.oldest > article.object.dateNum) ?
              article.object.dateNum : ($scope.ArticlesDisplayed.oldest === 0) ?
              article.object.dateNum : $scope.ArticlesDisplayed.oldest;
          $scope.articlesShown = true;
          return true;
        } else {
          delete $scope.ArticlesDisplayed[article.object.link];
          return false;
        }
      } else {
        $scope.ArticlesDisplayed[article.object.link] = true;
        // keep the oldest value (dateNum of oldest article in list) up to date
        $scope.ArticlesDisplayed.oldest =
              ($scope.ArticlesDisplayed.oldest > article.object.dateNum) ?
              article.object.dateNum : ($scope.ArticlesDisplayed.oldest === 0) ?
              article.object.dateNum : $scope.ArticlesDisplayed.oldest;
        $scope.articlesShown = true;
        return true;
      }
    };
  }

  return {
    restrict: 'E',
    scope: {
      'feeds': '=',
      'settings': '='
    },
    controller: ArticlesCtrl,
    templateUrl: '/res/js/feeds/articles.html.tpl',
    link: function (scope, element, attrs) {
      var divs = document.getElementsByClassName('article');
      for (var i = 0, num = divs.length; i < num; i = i + 1) {
        // grab all of the links inside the div
        var links = divs[i].getElementsByTagName('a');
        // Loop through those links and attach the target attribute
        for (var j = 0, jnum = links.length; j < jnum; j = j + 1) {
          // the _blank will make the link open in new window
          links[j].setAttribute('target', '_blank');
        }
      }
    }
  };
}]);;angular.module('dogfeed').

directive('butterbar', ['$rootScope',
function($rootScope) {
  return {
    link: function(scope, element, attrs) {
      element.addClass('hide');
      $rootScope.$on('$routeChangeStart', function() {
        element.removeClass('hide');
      });
      $rootScope.$on('$routeChangeSuccess', function() {
        element.addClass('hide');
      });
      $rootScope.$on('$routeChangeError', function (event, current, previous, rejection) {
        console.log('routeChangeError: ', rejection);
      });
    }
  };
}]).

directive('focus',
function() {
  return {
    link: function(scope, element, attrs) {
      element[0].focus();
    }
  };
});;  'use strict';

angular.module('ngRemoteStorage', ['ngCommandQueue']).

value('RemoteStorageConfig', {
  modules: []
}).

factory('RS', ['$rootScope', '$q', '$timeout', 'cQueue',
function ($rootScope, $q, $timeout, cQueue) {

  var ready = false;
  var connecting = false;

  function isConnected() {
    return remoteStorage.remote.connected;
  }

  function isConnecting() {
    return connecting;
  }

  remoteStorage.on('ready', function () {
    ready = true;
    connecting = false;
  });
  remoteStorage.on('connecting', function () {
    ready = false;
    connecting = true;
  });
  remoteStorage.on('authing', function () {
    connecting = true;
    ready = false;
  });
  remoteStorage.on('disconnected', function () {
    connecting = false;
    ready = true;
  });

  function callRS(job) {
    //console.log('callRS:', job);
    var p = remoteStorage[job.methods[0]][job.methods[1]].apply(null, job.params);
    p.then(function (res) {
      $rootScope.$apply(function () {
        if (job.defer) {
          job.defer.resolve(res);
        }
      });
    }, function (err) {
      $rootScope.$apply(function () {
        if (job.defer) {
          job.defer.reject(err);
        } else {
          console.log('error during RS call: ', err);
          throw new Error();
        }
      });
    });
  }

  var queue = cQueue.init(callRS);

  return {
    isConnected: isConnected,
    isConnecting: isConnecting,
    queue: function (module, func, params) {
      //console.log('RS.queue(' + module + ', ' + func + ', params):', params);
      queue.add({
        methods: [module, func],
        params: params,
        defer: false,
        timeout: 0,
        condition: isConnected
      });
    },
    call: function (module, func, params, failTimeout) {
      var defer = $q.defer();
      //console.log('RS.call(' + module + ', ' + func + ', params):', params);
      if ((typeof params === 'object') &&
          (typeof params[0] === 'undefined')) {
        defer.reject('RS.call params must be an array');
      } else {
        // put request onto queue
        queue.add({
          methods: [module, func],
          params: params,
          defer: defer,
          timeout: failTimeout,
          condition: function () { return true; } //isConnected
        });
      }
      return defer.promise;
    },
    on: function (module, event, func) {
      remoteStorage[module].on(event, func);
    }
  };
}]).


controller('remoteStorageCtrl',
['RemoteStorageConfig', '$scope',
function (RScfg, $scope) {
  remoteStorage.disableLog();

  $scope.$watch('RScfg.modules', function () {
    console.log('remoteStorageCtrl initializing modules: ', RScfg.modules);

    var mod, key;
    for (key in RScfg.modules) {
      mod = RScfg.modules[key];
      console.log('claim: '+mod[0]+ ' a: '+mod[1], mod);
      remoteStorage.access.claim(mod[0], mod[1]);
      if ((mod[2]) && (typeof mod[2].cache === 'boolean') && (!mod[2].cache)) {
        // disable caching
        remoteStorage.caching.disable('/'+mod[0]+'/');
        if ((mod[2]) && (typeof mod[2].public === 'boolean') && (mod[2].public)) {
          remoteStorage.caching.enable('/public/'+mod[0]+'/');
        } else {
          // disable public caching by default
          remoteStorage.caching.disable('/public/'+mod[0]+'/');
        }
      } else {
        // enable caching
        remoteStorage.caching.enable('/'+mod[0]+'/');
        if ((mod[2]) && (typeof mod[2].public === 'boolean') && (!mod[2].public)) {
          remoteStorage.caching.disable('/public/'+mod[0]+'/');
        } else {
          // enable public caching by default
          remoteStorage.caching.enable('/public/'+mod[0]+'/');
        }
      }
    }

    remoteStorage.displayWidget('remotestorage-connect', {
      redirectUri: window.location.protocol + '//' + window.location.host + '/rscallback.html'
    });

    for (key in RScfg.modules) {
      mod = RScfg.modules[key];
      if ((remoteStorage[mod[0]]) && (typeof remoteStorage[mod[0]].init === 'function')) {
        remoteStorage[mod[0]].init();
      }
    }
  });

}]);
;angular.module('ngCommandQueue', []).

factory('cQueue', ['$q', '$timeout',
function ($q, $timeout) {


  function cq(executeFunc, DEBUG) {
    /**
     * Variable: queue
     *
     * example structure:
     * {
     *   methods: (array)   // example: ['feeds', 'add']
     *   params: (array),
     *   condition: (function),
     *   defer: (object),
     *   timeout: (number)
     * }
     */
    var queue = [];
    var setTimedCheck = false;
    var interval = 1000;
    var throttle = 250;

    function propertyCheck(e) {
      var defer = $q.defer();
      try {
        if ((typeof e.methods !== 'object') ||
            (typeof e.methods[0] === 'undefined')) {
          console.error('methods property must be an array, indicating function order from left to right');
          defer.reject();
        } else if ((typeof e.params !== 'object') ||
                   (typeof e.params[0] === 'undefined')) {
          console.error('params property must be an array, indicating parameter order from left to right');
          defer.reject();
        } else if (typeof e.condition !== 'function') {
          e.condition = function () { return true; };
        } else if (typeof e.defer !== 'object') {
          e.defer = false;
        } else if (typeof e.timeout !== 'number') {
          e.timeout = 0;
        }
        e.age = 0;
        defer.resolve(e);
      } catch (error) {
        defer.reject(error);
      }
      return defer.promise;
    }

    function pushToQueue(e) {
      return propertyCheck(e).then(function (e) {
        if (DEBUG) { console.log('adding to queue: '+e.methods.join(' - ')); }
        e.id = Math.random(0, 9) * 100 / Math.random(0, 9);
        queue.push(e);
        setTimedCheck = true;
      });
    }

    function procSingleEntry() {
      if (queue.length <= 0) {
        setTimedCheck = false;
        return;
      }

      for (var i in queue) {
        // get entry off queue;
        var e = queue[i];
        if (!e.condition()) {
          if (DEBUG) { console.log(' procSingleEntry, condition NOT met. ',queue[i]); }
          break;
        }
        if (DEBUG) { console.log(' procSingleEntry, condition met ['+queue[i].id+']. ',queue[i]); }
        queue.splice(i, 1);
        try {
          executeFunc(e);
        } catch (error) {
          console.log('error : ', error);
          console.log('stack : ', error.stack);
          e.defer.reject(error);
        }
        break;
      }
      return;
    }

    (function procNextTick() {
      var i = 0;
      if (setTimedCheck) {
        // process a single entry from the queue every 'throttle' ms
        for (i in queue) {
          if ((queue[i].timeout !== 0) &&
              (queue[i].timeout < queue[i].age)) {
            if (DEBUG) { console.log('timing out ' + queue[i].methods.join('] [')); }
            queue[i].defer.reject('timed out');
            queue.splice(i, 1);
          } else {
            queue[i].age = queue[i].age + interval;
          }
        }
        $timeout(procSingleEntry, throttle);
      }

      $timeout(procNextTick, interval);
    })();

    return {
      add: pushToQueue
    };
  }

  return {
    init: function (executeFunc, DEBUG) {
      if (typeof executeFunc !== 'function') {
        throw new Error('cQueue init must pass a function to call when an entry from the queue is ready. The function should take the queue object as its first param');
      }
      return new cq(executeFunc, DEBUG);
    }
  };
}]);;angular.module('ngMessages', []).

value('MessagesConfig', {
  timeout: 3000
}).

directive('message',
['$rootScope', '$timeout', 'MessagesConfig',
function ($rootScope, $timeout, cfg) {
  return {
    restrict: 'A',
    template: '<div class="alert alert-{{ m.type }}" ng-show="haveMessage">'+
              '  <strong>{{m.title}}</strong> ' +
              '  <span>{{m.message}}</span>' +
              '</div>',
    link: function (scope) {
      scope.haveMessage = false;
      scope.m = {type: '', title: '', message: ''};

      var presets = {
        'remotestorage-connect': {
          type: 'warning',
          title : 'Connect to remoteStorage',
          message: 'to save your session'
        },
        'sockethub-config': {
          type: 'warning',
          title: 'Sockethub configuration needed',
          message: 'You must fill in your Sockethub connection details'
        },
        'sockethub-connect': {
          type: 'danger',
          title: 'Sockethub connection error',
          message: 'Unable to connect to Sockethub please check your configuration and try again'
        },
        'sockethub-register': {
          type: 'danger',
          title: 'Sockethub registration problem',
          message: 'We were unable to register with your Sockethub instance'
        },
        'xmpp-connect': {
          type: 'danger',
          title: 'XMPP connection failed',
          message: 'There was a problem connecting to the XMPP server, please verify you settings'
        },
        'unknown': {
          type: 'danger',
          title: 'An unknown error has occurred',
          message: ''
        }
      };

      $rootScope.$on('message', function (event, e) {
        //console.log('message event: ', e);

        var hasTimeout = (typeof e.timeout === 'boolean') ? e.timeout : true;
        scope.haveMessage = false;

        if (typeof e === 'undefined') {
          e = 'no error specified';
        }

        var defaultTitle = '';
        if (e.type === 'clear') {
          scope.haveMessage = false;
          scope.m = {type: '', title: '', message: ''};
          return;
        } else if (typeof presets[e.message] !== 'undefined') {
          scope.m = presets[e.message];
        } else if (typeof e.message === 'string') {
          if (e.type === 'success') {
            defaultTitle = 'Success';
          } else if (e.type === 'info') {
            defaultTitle = 'Info';
          } else {
            defaultTitle = "Error";
            e.type = 'danger';
          }
          scope.m.title = (e.title) ? e.title : defaultTitle;
          scope.m.message = e.message;
          scope.m.type = e.type;
        }

        var numTimeout = cfg.timeout;
        if ((e.topic) && (e.topic === 'sockethub') && (e.type === 'success')) {
          numTimeout = 1000;
        }
        scope.m.timeoutCount = numTimeout;

        scope.m.timeout = hasTimeout;
        //console.log('info message event set: ', scope.m);
        var message = scope.m.message;
        scope.haveMessage = true;
        if (hasTimeout) {
          $timeout(function () {
            if ((scope.m.timeout) && (message == scope.m.message)) {
              scope.haveMessage = false;
              scope.m = {type: '', title: '', message: '', timeout: true};
            }
          }, numTimeout);
        }
      });
    }
  };
}]);
;'use strict';

angular.module('ngSockethubClient', ['ngCommandQueue']).

/**
 * default settings
 */
value('SockethubSettings', {
  conn: {
    host: 'localhost',
    port: 10550,
    path: '/sockethub',
    tls: false,
    secret: '1234567890'
  },
  connected: false,
  connecting: false,
  registered: false,
  env: {
    logo: '/res/img/sockethub-logo.svg'
  },
  save: function (prop, obj) {
    if (this.verify(prop, obj)) {
      this[prop] = obj;
      this[prop].port = +obj.port;
      //console.log('SH SAVE [' + prop + ']: ', this[prop]);
      return true;
    } else {
      console.log('SH SAVE FAILED '+prop+': ', this[prop]);
      return false;
    }
  },
  exists: function (prop) {
    this.verify(prop, this.conn);
  },
  verify: function (prop, p) {
    if (!p) {
      p = this[prop];
    }
    if (prop === 'conn') {
      if ((p.host) && (p.host !== '') &&
          (p.port) && (p.port !== '') &&
          (p.path) && (p.path !== '') &&
          (typeof p.tls === 'boolean') &&
          (p.secret)) {
        return true;
      } else {
        return false;
      }
    } else {
      return true;
    }
  }
}).

/**
 * factory: SH
 */
factory('SH', ['$rootScope', '$q', '$timeout', 'SockethubSettings', 'cQueue',
function ($rootScope, $q, $timeout, settings, cQueue) {
  var sc;
  var callbacks = {
    'error': {},
    'message': {},
    'response': {},
    'close': {},
    'registered': {},
    'connected': {}
  };


  function isConnected() {
    if ((settings.connected) && (settings.registered)) {
      return true;
    } else {
      return false;
    }
  }

  function isConnecting() {
    return settings.connecting;
  }

  function isRegistered() {
    return settings.registered;
  }

  function callSH(job) {
    //console.log('callSH called ', job);
    sc[job.methods[0]].apply(sc, job.params)
      .then(function (e) {
        $rootScope.$apply(function () {
          job.defer.resolve(e);
        });
      }, function (e) {
        $rootScope.$apply(function () {
          job.defer.reject(e.message);
        });
      });
  }
  var queue = cQueue.init(callSH);

  function connect(p) {
    console.log('ngSockethubClient.connect() ', p);
    settings.connecting = true;
    settings.registered = false;
    settings.connected = false;
    var defer = $q.defer();
    var scheme = 'ws://';
    settings.connected = false;
    if (settings.conn.tls) {
      scheme = 'wss://';
    }

    var robj = {};
    if ((p) && (p.register)) {
      robj = {
        register: {
          secret: settings.conn.secret
        }
      };
    }

    console.log('Sockethub connect: '+scheme +
                                 settings.conn.host + ':' +
                                 settings.conn.port +
                                 settings.conn.path + ' register:'+ typeof robj.register);

    sc = SockethubClient.connect(scheme +
                                 settings.conn.host + ':' +
                                 settings.conn.port +
                                 settings.conn.path,
                                 robj
    );

    sc.on('connected', function () { // connected
      //console.log('Sockethub connected');
      if (callbacks.connected.sockethub) {
        $rootScope.$apply(callbacks.connected.sockethub());
      } else {
        if ((typeof p === 'object') && (!p.register)) {
          settings.connected = true;
          settings.connecting = false;
          // don't resolve the promise yet unless register was not requested
          // at the same time as connect
          $rootScope.$apply(function () {
            defer.resolve();
          });
        }
      }
    });

    sc.on('registered', function () { // connected & registered
      //console.log('Sockethub connected & registered');
      settings.connected = true;
      settings.connecting = false;
      settings.registered = true;
      if (callbacks.registered.sockethub) {
        $rootScope.$apply(callbacks.registered.sockethub());
      } else {
        try {
          $rootScope.$apply(function () {
            defer.resolve();
          });
        } catch (e) {
          console.log('ngSockethubClient ERROR: ', e);
        }
      }
    });

    sc.on('registration-failed', function (err) { // connected
      settings.registered = false;
      settings.connecting = false;
      console.log('Sockethub register failed ', err);
      $rootScope.$apply(function () {
        defer.reject(err);
      });
    });

    sc.on('failed', function (err) { // connection failed
      settings.registered = false;
      settings.connecting = false;
      settings.connected = false;
      console.log('Sockethub connection failed ', err);
      $rootScope.$apply(function () {
        defer.reject('Failed connecting to sockethub at ' + scheme +
                     settings.conn.host + ':' + settings.conn.port +
                     settings.conn.path);
      });
    });

    sc.on('disconnected', function (err) { // disconnected
      settings.registered = false;
      settings.connecting = false;
      settings.connected = false;
      console.log('SH received disconnect(close) '+err);
    });

    sc.on('message', function (data) { // message
      if ((data.platform) &&
          (callbacks.message[data.platform])) {
        //console.log('SH passing message to platform: '+data.platform);
        $rootScope.$apply(callbacks.message[data.platform](data));
      } else {
        console.log('SH received message with nothing to call: ', data);
      }
    });

    sc.on('unexpected-response', function (msg) {
      console.log('SH unexpected response: ', msg);
    });

    return defer.promise;
  }

  function register() {
    var defer = $q.defer();
    console.log('SH.register() called');
    queue.add({
      methods: ['register'],
      params: [{
        secret: settings.conn.secret
      }],
      defer: defer,
      timeout: 0,
      condition: isConnected
    });
    return defer.promise;
  }

  function sendSet(platform, type, index, object) {
    var defer = $q.defer();
    var data = {};
    data[type] = {};
    data[type][index] = object;
    queue.add({
      methods: ['set'],
      params: [platform, data],
      defer: defer,
      timeout: 0,
      condition: isRegistered
    });
    return defer.promise;
  }

  function callSubmit(obj, timeout) {
    var defer = $q.defer();
    queue.add({
      condition: isRegistered,
      methods: ['sendObject'],
      params: [obj, timeout],
      defer: defer,
      timeout: 0
    });
    return defer.promise;
  }

  function queueSubmit(obj, timeout) {
    queue.add({
      condition: isRegistered,
      methods: ['sendObject'],
      params: [obj, timeout],
      defer: false,
      timeout: 0
    });
  }

  var on = function on(platform, type, func) {
    callbacks[type][platform] = func;
  };

  return {
    connect: connect,
    register: register,
    isConnected: isConnected,
    isRegistered: isRegistered,
    isConnecting: isConnecting,
    set: sendSet,
    submit: {
      call: callSubmit,
      queue: queueSubmit
    },
    on: on
  };
}]).


directive('sockethubSettings', ['SH', '$rootScope', 'SockethubSettings',
function (SH, $rootScope, settings) {
  return {
    restrict: 'A',
    template: '<div class="col-xs-1"></div>' +
              '<div id="sockethubSettings" class="sockethub sockethub-form sockethub-settings col-xs-10">' +
              '  <div class="sockethub-logo" style="text-align: center;">' +
              '    <img data-ng-src="{{ sockethub.settings.env.logo }}" height="64" ng-cloak/>' +
              '  </div>' +
              '  <form name="settingsSockethub" role="form" class="form-horizontal" novalidate>' +
              '    <fieldset>' +
              '      <div class="form-group col-xs-12">' +
              '        <label for="host" class="control-label">Hostname</label>' +
              '        <div class="controls">' +
              '          <input type="text" class="required form-control" name="host" placeholder="Enter hostname..." ng-model="sockethub.settings.conn.host" required>' +
              '        </div>' +
              '      </div>' +
              '      <div class="form-group col-xs-12">' +
              '        <label for="port" class="control-label">Port</label>' +
              '        <div class="controls">' +
              '          <input type="text" class="required form-control" name="port" placeholder="Enter port..." ng-model="sockethub.settings.conn.port" required>' +
              '        </div>' +
              '      </div>' +
              '      <div class="form-group col-xs-12">' +
              '        <label for="path" class="control-label">Path</label>' +
              '        <div class="controls">' +
              '          <input type="text" class="required form-control" name="path" placeholder="Enter path (if any)..." ng-model="sockethub.settings.conn.path">' +
              '        </div>' +
              '      </div>' +
              '      <div class="form-group col-xs-12">' +
              '        <div class="">' +
              '          <div class="checkbox">' +
              '            <label>' +
              '              <input type="checkbox" name="tls" ng-model="sockethub.settings.conn.tls"> TLS'+
              '            </label>' +
              '          </div>' +
              '        </div>' +
              '      </div>' +
              '      <div class="form-group col-xs-12">' +
              '        <label for="secret" class="control-label">Secret</label>' +
              '        <div class="controls">' +
              '          <input type="text" class="required form-control" name="secret" placeholder="Enter secret..." ng-model="sockethub.settings.conn.secret" required>' +
              '        </div>' +
              '      </div>' +
              '    </fieldset>' +
              '    <div class="row">' +
              '         <div class="col-xs-2"></div>' +
              '         <div class="col-xs-4" style="padding:0 0 25px;margin:0 0 5px;">' +
              '           <button class="btn btn-primary" ng-click="sockethub.save(sockethub.settings.conn)" ' +
              '                   ng-disabled="!sockethub.settings.verify(\'conn\', sockethub.settings.conn) || saving">Submit</button>' +
              '         </div>' +
              '         <div class="col-sm-6" style="padding:0;margin:0 0 5px;">' +
              '           <button class="btn btn-default" ng-click="sockethub.useDefaults()">Populate Default Settings</button>' +
              '         </div>' +
              '    </div>' +
              '  </form>' +
              '</div>',
    link: function (scope) {
      scope.sockethub = {
        saving: false,
        settings: settings,
        useDefaults: function () {
          console.log('useDefaults() called: ', settings.defaultConn);
          for (var key in settings.defaultConn) {
            settings.conn[key] = settings.defaultConn[key];
          }
        }
      };
      scope.sockethub.save = function (cfg) {
        scope.sockethub.saving = true;
        /*$rootScope.$broadcast('message', {
              type: 'clear'
        });*/
        scope.sockethub.settings.save('conn', cfg);
        $rootScope.$broadcast('message', {
          message: 'attempting to connect to sockethub',
          type: 'info',
          topic: 'sockethub',
          timeout: false
        });
        SH.connect({register: true}).then(function () {
          scope.sockethub.saving = false;
          console.log('connected to sockethub');
          $rootScope.$broadcast('message', {
            message: 'connected to sockethub',
            type: 'success',
            topic: 'sockethub',
            timeout: true
          });
          $rootScope.$broadcast('sockethubSettingsSaved');
        }, function (err) {
          scope.sockethub.saving = false;
          console.log('error connection to sockethub: ', err);
          $rootScope.$broadcast('message', {
            message: err,
            type: 'error',
            topic: 'sockethub',
            timeout: false
          });
        });
      };
    }
  };
}]);;'use strict';

/**
 * helper modules to allow sockethub to bootstrap using remotestorage and to
 * write to remoteStorage when it needs to update it's sockethub config
 */
angular.module('ngSockethubRemoteStorage', ['ngSockethubClient', 'ngRemoteStorage']).

value('srsLocalSettings', {
  appName: 'default'
}).

/**
 * run
 */
run(['$rootScope', 'SockethubSettings', 'SH', 'RS', 'srsLocalSettings',
function ($rootScope, settings, SH, RS, localSettings) {
  //SH.on('sockethub', 'registered', function () {
  $rootScope.$on('sockethubSettingsSaved', function () {
    // sockethub connected, save settings to RS
    console.log('Sockethub-RemoteStorage: saving sockethub config to remoteStorage ', settings.conn);
    RS.call('sockethub', 'writeConfig', [localSettings.appName, settings.conn]).then(function () {
      //console.log('config saved to RS');
    }, function (err) {
      //console.log('Sockethub-RemoteStorage: Failed saving sockethub config to remoteStorage: ',err);
      $rootScope.$broadcast('message', {
        message: 'failed saving sockethub config to remote storage',
        type: 'error',
        topic: 'remotestorage',
        timeout: true
      });
    });
  });
}]).

factory('SockethubBootstrap', ['RS', 'SockethubSettings', '$rootScope', 'SH', '$timeout', 'srsLocalSettings',
function (RS, settings, $rootScope, SH, $timeout, localSettings) {
  function run(appName, defaultCfg, envObj) {

    if (typeof appName === 'string') {
      localSettings.appName = appName;
    }

    if (typeof defaultCfg === 'object') {
      settings.save('conn', defaultCfg);
      settings.save('defaultConn', defaultCfg);
    }

    if (typeof envObj === 'object') {
      settings.save('env', envObj);
    }

    function connect(cfg) {
      //console.log('USING SH CONFIG: ', cfg);
      //$rootScope.$broadcast('message', {type: 'clear'});
      // connect to sockethub and register
      if (settings.save('conn', cfg)) {
        $rootScope.$broadcast('message', {
          message: 'attempting to connect to sockethub',
          type: 'info',
          topic: 'sockethub',
          timeout: false
        });
        SH.connect({register: true}).then(function () {
          //console.log('connected to sockethub');
          $rootScope.$broadcast('message', {
            message: 'connected to sockethub',
            type: 'success',
            topic: 'sockethub',
            timeout: true
          });
        }, function (err) {
          console.log('error connecting to sockethub: ', err);
          $rootScope.$broadcast('SockethubConnectFailed', {message: err});
        });
      } else {
        $rootScope.$broadcast('message', {
          message: 'failed saving sockethub credentials',
          topic: 'sockethub',
          type: 'error',
          timeout: true
        });
      }
    }

    RS.call('sockethub', 'getConfig', [localSettings.appName]).then(function (c) {
      console.log('GOT SH CONFIG: ', c);
      var cfg = {};

      if ((typeof c !== 'object') || (typeof c.host !== 'string')) {
        //cfg = settings.conn;
        cfg = defaultCfg;
      } else {
        cfg = c;
      }
      connect(cfg);
    }, function (err) {
      console.log('RS.call error: ', err);
      if (defaultCfg) {
        console.log('attempting to fallback to default config: ', defaultCfg);
        connect(defaultCfg);
      }
    });
  }

  return {
    run: run
  };
}]);