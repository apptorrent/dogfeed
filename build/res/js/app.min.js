angular.module('dogfeed', ['ngFeeds', 'ngSockethubClient', 'ngRemoteStorage', 'ngMessages']).

/**
 * routes
 */
config(['$routeProvider',
function ($routeProvider) {
  $routeProvider.
    when('/', {
      templateUrl: "feeds.html"
    }).
    otherwise({
      redirectTo: "/"
    });
}]).

/**
 * remotestorage config
 */
run(['RemoteStorageConfig',
function (RScfg) {
  RScfg.modules = [
    ['sockethub', 'rw', {'cache': false}],
    ['feeds', 'rw', {'cache': false}],
    ['articles', 'rw', {'cache': false}]
  ];
}]).

/**
 * messages config
 */
run(['MessagesConfig',
function (cfg) {
  cfg.timeout = 15000;
}]).

/**
 * get sockethub settings and try to connect
 */
run(['SockethubSettings', 'SH', 'RS', '$rootScope',  '$timeout',
function (settings, SH, RS, $rootScope, $timeout) {

  var default_cfg = {
    host: 'silverbucket.net',
    port: 443,
    path: '/sockethub',
    tls: true,
    secret: '1234567890'
  };

  function sockethubConnect(cfg) {
    console.log('USING SH CONFIG: ', cfg);
    // connect to sockethub and register
    if (settings.save('conn', cfg)) {
      $rootScope.$broadcast('message', {
            message: 'attempting to connect to sockethub',
            type: 'info',
            timeout: false
      });
      SH.connect({register: true}).then(function () {
        $rootScope.$broadcast('message', {
              message: 'connected to sockethub',
              type: 'success',
              timeout: true
        });
      }, function (err) {
        console.log('error connecting to sockethub: ', err);
        $rootScope.$broadcast('SockethubConnectFailed', {message: err});
      });
    } else {
      $rootScope.$broadcast('message', {
            message: 'failed saving sockethub credentials',
            type: 'success',
            timeout: true
      });
    }
  }

  RS.call('sockethub', 'getConfig', ['dogfeed'], 3000).then(function (c) {
    console.log('GOT SH CONFIG: ', c);
    if ((typeof c !== 'object') || (typeof c.host !== 'string')) {
      //cfg = settings.conn;
      c = default_cfg;
    }
    sockethubConnect(c);
  }, function (err) {
    console.log("RS.call error: ",err);
    sockethubConnect(default_cfg);
  });
}]).


/**
 * remoteStorage
 */
run(['SockethubSettings', 'SH', '$rootScope', 'RS', '$timeout',
function (settings, SH, $rootScope, RS, $timeout) {
  if (!RS.isConnected()) {
    $timeout(function () {
      if (!RS.isConnected()) {
        $rootScope.$broadcast('message', {message: 'remotestorage-connect', timeout: false});
      }
    }, 6000);
  }
}]).

/**
 * modal window listeners/emitters
 */
run(['$rootScope',
function ($rootScope) {
  $rootScope.$on('showModalAddFeed', function(event, args) {
    backdrop_setting = true;
    if ((typeof args === 'object') && (typeof args.locked !== 'undefined')) {
      if (args.locked) {
        backdrop_setting = "static";
      }
    }
    $("#modalAddFeed").modal({
      show: true,
      keyboard: true,
      backdrop: backdrop_setting
    });
  });

  $rootScope.$on('closeModalAddFeed', function(event, args) {
    $("#modalAddFeed").modal('hide');
  });
}]).

/**
 * filter: urlEncode
 */
filter('urlEncode', [
function() {
  return function (text, length, end) {
    return encodeURIComponent(escape(text));
  };
}]).

/**
 * filter: fromNow (date)
 */
filter('fromNow', [
function() {
  return function (dateString) {
    return new Date(dateString).toDateString(); ///moment(new Date(dateString)).fromNow();
  };
}]).

/**
 * filter: pagination
 */
filter('pagination', [
function() {
  var count = 0;
  var max = 3;
  return function (article) {
    console.log("pagination received: ", article);
    if (!article) { return false; }
    count = count + 1;
    if (count > 10) {
      console.log('pagination returned false');
      return false;
    }
    console.log('pagination returned article: ',article);
    return article;
  };
}]).

///////////////////////////////////////////////////////////////////////////
//
// CONTROLLERS
//
///////////////////////////////////////////////////////////////////////////

/**
 * controller: titlebarCtrl
 */
controller('titlebarCtrl',
['$scope', '$rootScope', 'SockethubSettings', 'RS',
function ($scope, $rootScope, settings, RS) {
  $scope.addFeed = function () {
    $rootScope.$broadcast('showModalAddFeed', {locked: false});
  };
  $scope.sockethubSettings = function () {
    $rootScope.$broadcast('showModalSockethubSettings', {locked: false});
  };

  $scope.$watch('settings.connected', function (newVal, oldVal) {
    if (settings.connected) {
      settings.conn.port = Number(settings.conn.port);
      RS.call('sockethub', 'writeConfig', [settings.conn]).then(function () {
        console.log("Sockethub config saved to remoteStorage");
      }, function (err) {
        console.log('Failed saving Sockethub config to remoteStorage: ', err);
      });
    }
  });
}]);;angular.module('ngFeeds', ['ngRemoteStorage', 'ngSockethubClient']).


/**
 * settings service
 */
value('configHelper', {
  exists: function exists(config, cfg) {
    if (!cfg) {
      cfg = config;
    }

    for (var key in config) {
      if (!cfg[key]) {
        return false;
      }
    }
    return true;
  },
  set: function (config, cfg) {
    for (var key in cfg) {
      config[key] = cfg[key];
    }
    return config;
  }
}).

run(['$routeParams', '$rootScope', 'Feeds',
function ($routeParams, $rootScope, Feeds) {

  $rootScope.feeds = Feeds.data;

}]).


///////////////////////////////////////////////////////////////////////////
//
// FACTORY
//
///////////////////////////////////////////////////////////////////////////

/**
 * Factory: Feeds
 */
factory('Feeds', ['$q', 'SH', 'configHelper', 'RS', '$rootScope',
function ($q, SH, CH, RS, $rootScope) {

  var config = {};
  var data = {
    articles: [],
    info: {},
    infoArray: [],
    groups: {},
    groupArray: []
  };
  var func = {};

  /****
   * CONFIG MANAGEMENT
   ********************/
  function exists(cfg) {
    return CH.exists(config, cfg);
  }

  func.setConfig = function set(cfg) {
    var defer = $q.defer();
    if (exists(cfg)) {
      if (cfg) {
        CH.set(config, cfg);
      }
      defer.resolve(config);
    } else {
      defer.reject('config not set correctly');
    }
    return defer.promise;
  };


  /****
   * ARTICLE MANAGEMENT
   *********************/
  // update or create an article entry on remoteStorage
  func.updateArticle = function updateArticle(obj) {
    var defer = $q.defer();
    var s_obj = {
      link: obj.object.link,
      title: obj.object.title,
      date: obj.object.date,
      html: obj.object.html,
      text: obj.object.text,
      brief_html: obj.object.brief_html,
      brief_text: obj.object.brief_text,
      read: (obj.object.read) ? true : false,
      source_link: obj.actor.address,
      source_title: obj.actor.name
    };

    RS.call('articles', 'update', [s_obj]).then(function (m) {
      //console.log('article added: ', m);
      //data.info[obj.url] = obj;
      //func.fetchFeed(obj.url);
      defer.resolve(m);
    }, function (err) {
      defer.reject(err);
    });
    return defer.promise;
  };


  /****
   * FEED MANAGEMENT
   ******************/
  // grab whatever feeds exists in remoteStorage right away
  (function getFeedUrls() {
    RS.call('feeds', 'getAll', ['']).then(function (urls) {
      console.log('Feeds: got feed urls from remoteStorage ', urls);
      for (var key in urls) {
        if ((!urls[key]) || (typeof urls[key].url === 'undefined')) {
          console.log('ERROR processing url['+key+']: ', urls[key]);
        } else {
          var url = urls[key].url;
          urls[key].unread = 0;
          func.fetchFeed(urls[key].url); // asign existing feed info to data struct
        }
      }
    }, function (err) {
      console.log('error: unable to get feed list from remoteStorage: ', err);
      $rootScope.$broadcast('message', {
        message: 'unable to get feed list from remotestorage',
        type: 'error',
        timeout: false
      });
    });
  })();

  /**
   * Function: addFeed
   *
   * take a record from sockethub and creates a feed entry, queueing to store
   * in rs
   *
   * Parameters:
   *
   *   m - article object recevied from sockethub
   *
   */
  function addFeed (m) {
    var obj = {
      url: m.actor.address,
      name: m.actor.name,
      cache_articles: 20,
      last_fetched: new Date().getTime(),
      unread: 0
    };
    data.info[obj.url] = obj;
    data.infoArray.push(obj);
    RS.queue('feeds', 'add', [obj]);
  }

  /**
   * Function: updateFeed
   *
   * update feed with the passed in feed object
   *
   * Parameters:
   *
   *   obj - feed object (remotestorage format)
   */
  func.updateFeed = function (obj) {
    var defer = $q.defer();
    RS.call('feeds', 'add', [obj]).then(function (m) {
      //console.log('feed updated: ', obj);
      data.info[obj.url] = obj;
      defer.resolve(m);
    }, function (err) {
      defer.reject(err);
    });
    return defer.promise;
  };

  /**
   * Function: removeFeed
   *
   * remove a feed from the feed lists and remotestorage
   *
   * Parameters:
   *
   *   url - feed url
   */
  func.removeFeed = function (url) {
    var defer = $q.defer();
    RS.call('feeds', 'remove', [url]).then(function (m) {
      delete data.info[url];
      for (var i = 0, len = data.infoArray.length; i < len; i = i + 1) {
        if ((data.infoArray[i]) && (data.infoArray[i].url === url)) {
          //console.log('removing from list: ',data.infoArray[i]);
          data.infoArray.splice(i, 1);
          break;
        }
      }
      console.log('articles count: '+data.articles.length);
      for (i = 0, len = data.articles.length; i < len; i = i + 1) {
        if ((data.articles[i]) && (data.articles[i].actor.address === url)) {
          //console.log('removing article from list: ',data.articles[i]);
          data.articles.splice(i, 1);
        }
      }
      console.log('articles count: '+data.articles.length);
      console.log('feed removed: ', url);
      defer.resolve(m);
    }, function (err) {
      defer.reject(err);
    });
    return defer.promise;
  };


  /****
   * FEED FETCHING
   ****************/
  var feedsTried = {};
  // issue orders to fetch feeds from sockethub
  func.fetchFeed = function fetch(url) {
    var match = false;
    for (var i = 0, len = data.infoArray.length; i < len; i = i + 1) {
      if ((data.infoArray[i]) && (data.infoArray[i].url === url)) {
        match = true;
        break;
      }
    }
    if ((match) || (feedsTried[url])) {
      return;
    }
    feedsTried[url] = true;

    var msg = {
      verb: 'fetch',
      platform: 'rss',
      actor: {
        address: 'rss'
      },
      target: [{
        address: url
      }]
    };
    console.log("FETCH: ", msg);
    SH.submit.call(msg).then(function (o) {
      data.info[url]['loaded'] = true;
    }, function (e) {
      console.log('failed fetch');
      $rootScope.$broadcast('message', {
        message: 'failed fetching feed: '+e,
        type: 'error'
      });
    });
  };


  //
  //
  // detect when new articles are received from Sockethub
  SH.on('rss', 'message', function (m) {
    console.log("Feeds received message ",m);
    var key = m.actor.address;
    if (!m.status) {
      console.log('received error message from sockethub: ', m);
      $rootScope.$broadcast('message', {
        type: 'error',
        message: m.target[0].address + ' ' + m.message
      });
      return;
    }


    // check if the feed entry for this article exists yet, if not add it.
    // also check to update name.
    if (!data.info[key]) {
      console.log('#### - adding to data.info: ',m);
      addFeed(m);
    } else if ((!data.info[key].name) || (data.info[key].name === data.info[key].url)) {
      console.log('#### - updating name: ',m);
      data.info[key]['name'] = m.actor.name;
    }

    if (!m.object.read) {
      m.object.read = false;
      data.info[key].unread = (typeof data.info[key].unread === "number") ? data.info[key].unread + 1 : 1;
    }

    // add article to article list
    data.articles.push(m);

    // fetch article from remoteStorage if exists
    RS.call('articles', 'getByUrl', [m.object.link]).then(function (a) {
      if (a) {
        //console.log('ARTICLE FETCH from RS: ', a);
        m.object.read = (a.read) ? a.read : false;
      }

      if (m.object.read) {
        // this article is read, subtract from total
        data.info[key].unread = (typeof data.info[key].unread === "number") ? data.info[key].unread - 1 : 0;
      }
    }, function (e) {
      console.log("ARTICLE FETCH ERROR: ", e);
    });
  });

  return {
    config: config,
    data: data,
    func: func
  };
}]).


///////////////////////////////////////////////////////////////////////////
//
// CONTROLLERS
//
///////////////////////////////////////////////////////////////////////////

/**
 * controller: addFeedCtrl
 */
controller('addFeedCtrl',
['$scope', 'Feeds',
function ($scope, Feeds) {
  $scope.adding = false;

  $scope.add = function (url) {
    $scope.adding = true;
    Feeds.func.fetchFeed(url);
    $scope.adding = false;
  };

}]).

/**
 * controller: feedSettingsCtrl
 */
controller('feedSettingsCtrl',
['$scope', 'Feeds',
function ($scope, Feeds) {
  $scope.saving = false;

  $scope.saveFeedSettings = function (feed) {
    $scope.saving = true;
    Feeds.func.updateFeed(feed).then(function () {
      $("#modalFeedSettings").modal('hide');
      $rootScope.$broadcast('message', {type: 'success', message: 'updated feed ' + url});
      $scope.saving = false;
    }, function (err) {
      console.log('rss feed update failed!: ', err);
      $rootScope.$broadcast('message', {type: 'error', message: err.message});
      $("#modalFeedSettings").modal('hide');
      $scope.saving = false;
    });
  };

  $scope.cancelFeedSettings = function () {
    $("#modalFeedSettings").modal('hide');
    $scope.model.feeds.info[$scope.feeds.edit].name = $scope.model.feeds._editName;
    $scope.saving = false;
  };
}]).

/**
 * controller: feedCtrl
 */
controller('feedCtrl',
['$scope', 'Feeds', '$rootScope', '$timeout', '$routeParams',
function ($scope, Feeds, $rootScope, $timeout, $routeParams) {
  console.log('--- feedCtrl');
  $scope.model = {
    settings: {
      showRead: true,  // show read articles or disappear them
      articlesPerPage: 10,  // number of articles to show per page
      displayCap: 5,  // current limit of articles to show (increments by articlesPerPage)
      displayed: {}  // index of displayed articles
    }
  };

  $scope.saving = false;

  $rootScope.feeds.current = {
    name: '',
    indexes: []
  };

  $rootScope.feeds.edit = {
    name: '',
    url: '',
    origName: ''
  };

  if ($routeParams.feed) {
    // if we have a url as a param, we try to fetch it
    $rootScope.$broadcast('message', {
      message: 'attempting to fetch feed from '+$routeParams.feed,
      type: 'info'
    });
    $rootScope.selectedFeed = $routeParams.feed;
    Feeds.func.fetchFeed($routeParams.feed);
  }

  $scope.deleteFeed = function (url) {
    $scope.saving = true;
    Feeds.func.removeFeed(url).then(function () {
      $("#modalFeedSettings").modal('hide');
      $rootScope.$broadcast('message', {type: 'success', message: 'deleted feed '+url});
      $scope.saving = false;
      if ($scope.isSelected(url)) {
        $scope.switchFeed(url);
      }
    }, function (err) {
      console.log('error removing rss feed!: ', err);
      $rootScope.$broadcast('message', {type: 'error', message: err.message});
      $("#modalFeedSettings").modal('hide');
      $scope.saving = false;
    });
  };

  $rootScope.$on('SockethubConnectFailed', function (event, e) {
    console.log('Sockethub connect failed! ', e);
    $rootScope.$broadcast('message', {
      message: e.message,
      type: 'error',
      timeout: false
    });
    //$scope.model.loading = true;
    $rootScope.$broadcast('showModalSockethubSettings', {locked: false});
  });
}]).


///////////////////////////////////////////////////////////////////////////
//
// DIRECTIVES
//
///////////////////////////////////////////////////////////////////////////

value('isSelected', function ($scope, url, inclusive) {
  if ($scope.feeds.current.indexes.length === 0) {
    if ((inclusive) || (!url)) {
      return true;
    } else {
      return false;
    }
  } else {
    for (var i = 0, num = $scope.feeds.current.indexes.length; i < num; i = i + 1) {
      if ($scope.feeds.current.indexes[i] === url) {
        return true;
      }
    }
  }
  return false;
}).

/**
 * directive: feedList
 */
directive('feedList', ['isSelected',
function (isSelected) {
  function FeedListCtrl ($scope) {

    $scope.isSelected = function (url, inclusive) {
      return isSelected.apply(this, [$scope, url, inclusive]);
    };

    $scope.switchFeed = function (url, groupId, error) {
      console.log('SWITCH FEED: '+url, $scope.feeds);
      if (error) { return false; }
      if (!url) {
        $scope.feeds.current.name = '';
        $scope.feeds.current.indexes.length = 0;
      } else {
        $scope.feeds.current.name = $scope.feeds.info[url].name;
        $scope.feeds.current.indexes = [url];
      }
    };

    $scope.showFeedSettings = function (url) {
      console.log('showFeedSettings: '+url);
      if (!url) { return; }
      $scope.feeds.edit.url = url;
      $scope.feeds.edit.name = $scope.feeds.info[url].name;
      $scope.feeds.edit.origName = $scope.feeds.info[url].name;
      $("#modalFeedSettings").modal({
        show: true,
        keyboard: true,
        backdrop: true
      });
    };
  }

  return {
    restrict: 'E',
    scope: {
      'feeds': '=',
      'settings': '='
    },
    templateUrl: 'res/js/feeds/feeds.html.tpl',
    controller: FeedListCtrl,
    transclude: true
  };
}]).

/**
 * directive: articles
 */
directive('articles', ['isSelected', 'Feeds',
function (isSelected, Feeds) {
  function ArticlesCtrl($scope) {

    $scope.isSelected = function (url, inclusive) {
      return isSelected.apply(this, [$scope, url, inclusive]);
    };

    // returns true if current selection is empty (has no unread articles)
    $scope.currentIsEmpty = function (settings) {
      //console.log('CALLED: ', settings);
      if (!$scope.feeds.current.name) {
        return false;
      }
      for (var i = 0, num = $scope.feeds.current.indexes.length; i < num; i = i + 1) {
        //console.log('checking '+$scope.model.feeds.current.indexes[i], $scope.model.feeds.info[$scope.model.feeds.current.indexes[i]]);
        if (($scope.feeds.info[$scope.feeds.current.indexes[i]]) &&
            ($scope.feeds.info[$scope.feeds.current.indexes[i]].unread > 0)) {
          return false;
        }
        if (settings.showRead) {
          return false;
        }
      }
      return true;
    };

    $scope.markRead = function (url, val) {
      //console.log('markRead Called! val:'+val);
      for (var i = 0, num = $scope.feeds.articles.length; i < num; i = i + 1) {
        //console.log('A.link: ' + $scope.feeds.articles[i].object.link + ' url: '+url);
        if ($scope.feeds.articles[i].object.link === url) {
          //console.log('R:'+$scope.feeds.articles[i].object.read+' v:'+val);
          if ((!$scope.feeds.articles[i].object.read) && (val)) {
            //console.log('subtracting 1 from : '+ $scope.feeds.info[$scope.feeds.articles[i].actor.address].unread);
            $scope.feeds.info[$scope.feeds.articles[i].actor.address].unread =
                $scope.feeds.info[$scope.feeds.articles[i].actor.address].unread - 1;
          } else if (($scope.feeds.articles[i].object.read) && (!val)) {
            //console.log('adding 1 to : '+ $scope.feeds.info[$scope.feeds.articles[i].actor.address].unread);
            $scope.feeds.info[$scope.feeds.articles[i].actor.address].unread =
                $scope.feeds.info[$scope.feeds.articles[i].actor.address].unread + 1;
          }
          $scope.feeds.articles[i].object.read = val;
          Feeds.func.updateArticle($scope.feeds.articles[i]);
          return;
        }
      }
    };

    $scope.isShowable = function (feedUrl, isRead, settings, articleUrl) {
      if (!$scope.isSelected(feedUrl, true)) {
        return false;
      }

      if (settings.displayed[articleUrl]) {
        return true;
      }

      if (Object.keys(settings.displayed).length >= settings.displayCap) {
        return false;
      }

      if (isRead) {
        if (settings.showRead) {
        console.log('D');
          settings.displayed[articleUrl] = true;
          return true;
        } else {
        console.log('E');
          return false;
        }
      } else {
        settings.displayed[articleUrl] = true;
        console.log('F ', settings.displayed);
        return true;
      }
    };
  }

  return {
    restrict: 'E',
    scope: {
      'feeds': '=',
      'settings': '='
    },
    controller: ArticlesCtrl,
    templateUrl: 'res/js/feeds/articles.html.tpl',
    link: function (scope, element, attrs) {
      var divs = document.getElementsByClassName('article');
      for (var i = 0, num = divs.length; i < num; i = i + 1) {
        // grab all of the links inside the div
        var links = divs[i].getElementsByTagName('a');
        // Loop through those links and attach the target attribute
        for (var j = 0, jnum = links.length; j < jnum; j = j + 1) {
          // the _blank will make the link open in new window
          links[j].setAttribute('target', '_blank');
        }
      }
    }
  };
}]);;angular.module('ngRemoteStorage', ['ngCommandQueue']).

value('RemoteStorageConfig', {
  modules: []
}).

factory('RS', ['$rootScope', '$q', '$timeout', 'cQueue',
function ($rootScope, $q, $timeout, cQueue) {

  var ready = false;

  function isConnected() {
    return remoteStorage.remote.connected;
  }

  remoteStorage.on('ready', function () {
    ready = true;
  });

  function callRS(job) {
    console.log('callRS:', job);
    remoteStorage[job.methods[0]][job.methods[1]].apply(null, job.params).
      then(function (res) {
        $rootScope.$apply(function () {
          if (job.defer) {
            job.defer.resolve(res);
          }
        });
      }, function (err) {
        $rootScope.$apply(function () {
          if (job.defer) {
            job.defer.reject(err);
          } else {
            throw new Error(err);
          }

        });
      });
  }

  var queue = cQueue.init(callRS);

  return {
    isConnected: isConnected,
    queue: function (module, func, params) {
      console.log('RS.queue(' + module + ', ' + func + ', params):', params);
      queue.add({
        methods: [module, func],
        params: params,
        defer: false,
        timeout: 0,
        condition: isConnected
      });
    },
    call: function (module, func, params, failTimeout) {
      var defer = $q.defer();
      console.log('RS.call(' + module + ', ' + func + ', params):', params);
      if ((typeof params === 'object') &&
          (typeof params[0] === 'undefined')) {
        defer.reject('RS.call params must be an array');
      } else {
        // put request onto queue
        queue.add({
          methods: [module, func],
          params: params,
          defer: defer,
          timeout: failTimeout,
          condition: isConnected
        });
      }
      return defer.promise;
    }
  };
}]).


controller('remoteStorageCtrl',
['RemoteStorageConfig', '$scope',
function (RScfg, $scope) {
  remoteStorage.disableLog();

  $scope.$watch('RScfg.modules', function () {
    console.log('remoteStorageCtrl initializing modules: ', RScfg.modules);

    var mod, key;
    for (key in RScfg.modules) {
      mod = RScfg.modules[key];
      console.log('claim: '+mod[0]+ ' a: '+mod[1]);
      remoteStorage.access.claim(mod[0], mod[1]);
      if ((mod[2]) && (typeof mod[2].cache === 'boolean') && (!mod[2].cache)) {
        // disable caching
        remoteStorage.caching.disable('/'+mod[0]+'/');
      }
    }

    remoteStorage.displayWidget('remotestorage-connect', {
      redirectUri: window.location.protocol + '//' + window.location.host + '/rscallback.html'
    });

    for (key in RScfg.modules) {
      mod = RScfg.modules[key];
      if ((remoteStorage[mod[0]]) && (typeof remoteStorage[mod[0]].init === 'function')) {
        remoteStorage[mod[0]].init();
      }
    }
  });

}]);
;angular.module('ngCommandQueue', []).

factory('cQueue', ['$q', '$timeout',
function ($q, $timeout) {


  function cq(executeFunc) {
    /**
     * Variable: queue
     *
     * example structure:
     * {
     *   methods: (array)   // example: ['rss', 'add']
     *   params: (array),
     *   condition: (function),
     *   defer: (object),
     *   timeout: (number)
     * }
     */
    var queue = [];
    var setTimedCheck = false;
    var interval = 1000;
    var throttle = 250;

    function propertyCheck(e) {
      var defer = $q.defer();
      try {
        if ((typeof e.methods !== 'object') ||
            (typeof e.methods[0] === 'undefined')) {
          console.error('methods property must be an array, indicating function order from left to right');
          defer.reject();
        } else if ((typeof e.params !== 'object') ||
                   (typeof e.params[0] === 'undefined')) {
          console.error('params property must be an array, indicating parameter order from left to right');
          defer.reject();
        } else if (typeof e.condition !== 'function') {
          e.condition = function () { return true; };
        } else if (typeof e.defer !== 'object') {
          e.defer = false;
        } else if (typeof e.timeout !== 'number') {
          e.timeout = 0;
        }
        e.age = 0;
        defer.resolve(e);
      } catch (error) {
        defer.reject(error);
      }
      return defer.promise;
    }

    function pushToQueue(e) {
      return propertyCheck(e).then(function (e) {
        console.log('adding to queue: '+e.methods.join(' - '));
        queue.push(e);
        setTimedCheck = true;
      });
    }

    function procSingleEntry() {
      if (queue.length <= 0) {
        setTimedCheck = false;
        return;
      }

      for (var i in queue) {
        // get entry off queue;
        var e = queue[i];
        if (!e.condition()) {
          break;
        }

        queue.splice(i, 1);
        try {
          executeFunc(e);
        } catch (error) {
          console.log('error : ', error);
          console.log(error.stack);
          e.promise.reject(error);
        }
        break;
      }
      return;
    }

    (function procNextTick() {
      var i = 0;
      if (setTimedCheck) {
        // process a single entry from the queue every 'throttle' ms
        for (i in queue) {
          if ((queue[i].timeout !== 0) &&
              (queue[i].timeout < queue[i].age)) {
            console.log('timing out ' + queue[i].methods.join('] ['));
            queue[i].defer.reject('timed out');
            queue.splice(i, 1);
          } else {
            queue[i].age = queue[i].age + interval;
          }
        }
        $timeout(procSingleEntry, throttle);
      }

      $timeout(procNextTick, interval);
    })();

    return {
      add: pushToQueue
    };
  }

  return {
    init: function (executeFunc) {
      if (typeof executeFunc !== 'function') {
        throw new Error('cQueue init must pass a function to call when an entry from the queue is ready. The function should take the queue object as its first param');
      }
      return new cq(executeFunc);
    }
  };
}]);;angular.module('ngMessages', []).

value('MessagesConfig', {
  timeout: 4000
}).

directive('message',
['$rootScope', '$timeout', 'MessagesConfig',
function ($rootScope, $timeout, cfg) {
  return {
    restrict: 'A',
    template: '<div class="alert alert-{{ m.type }}" ng-show="haveMessage">'+
              '  <strong>{{m.title}}</strong> ' +
              '  <span>{{m.message}}</span>' +
              '</div>',
    link: function (scope) {
      scope.haveMessage = false;
      scope.m = {type: '', title: '', message: ''};

      var presets = {
        'remotestorage-connect': {
          type: 'warning',
          title : 'Connect to remoteStorage',
          message: 'if you want your changes to persist'
        },
        'sockethub-config': {
          type: 'warning',
          title: 'Sockethub configuration needed',
          message: 'You must fill in your Sockethub connection details'
        },
        'sockethub-connect': {
          type: 'danger',
          title: 'Sockethub connection error',
          message: 'Unable to connect to Sockethub please check your configuration and try again'
        },
        'sockethub-register': {
          type: 'danger',
          title: 'Sockethub registration problem',
          message: 'We were unable to register with your Sockethub instance'
        },
        'xmpp-connect': {
          type: 'danger',
          title: 'XMPP connection failed',
          message: 'There was a problem connecting to the XMPP server, please verify you settings'
        },
        'unknown': {
          type: 'danger',
          title: 'An unknown error has occurred',
          message: ''
        }
      };

      $rootScope.$on('message', function (event, e) {
        //console.log('message event: ', e);

        var timeout = (typeof e.timeout === 'boolean') ? e.timeout : true;
        scope.haveMessage = false;

        if (typeof e === 'undefined') {
          e = 'no error specified';
        }

        if (e.type === 'clear') {
          scope.haveMessage = false;
          scope.m = {type: '', title: '', message: ''};
          return;
        } else if (typeof presets[e.message] !== 'undefined') {
          scope.m = presets[e.message];
        } else if (typeof e.message === 'string') {
          if (e.type === 'success') {
            scope.m.title = 'Success';
          } else if (e.type === 'info') {
            scope.m.title = 'Info';
          } else {
            scope.m.title = "Error";
            e.type = 'danger';
          }
          scope.m.message = e.message;
          scope.m.type = e.type;
        }
        scope.m.timeout = timeout;
        console.log('info message event set: ', scope.m);
        var message = scope.m.message;
        scope.haveMessage = true;
        if (timeout) {
          $timeout(function () {
            if ((scope.m.timeout) && (message == scope.m.message)) {
              scope.haveMessage = false;
              scope.m = {type: '', title: '', message: '', timeout: true};
            }
          }, cfg.timeout);
        }
      });
    }
  };
}]);
;angular.module('ngSockethubClient', ['ngCommandQueue']).

/**
 * default settings
 */
value('SockethubSettings', {
  conn: {
    host: 'localhost',
    port: 10550,
    path: '/sockethub',
    tls: false,
    secret: '1234567890'
  },
  connected: false,
  env: {
    logo: '/res/img/sockethub-logo.svg'
  },
  save: function (prop, obj) {
    if (this.verify(prop, obj)) {
      this[prop] = obj;
      this[prop].port = +obj.port;
      console.log('SH SAVE [' + prop + ']: ', this[prop]);
      return true;
    } else {
      console.log('SH SAVE FAILED '+prop+': ', this[prop]);
      return false;
    }
  },
  exists: function (prop) {
    this.verify(prop, settings.conn);
  },
  verify: function (prop, p) {
    if (!p) {
      p = this[prop];
    }
    if ((p.host) && (p.host !== '') &&
        (p.port) && (p.port !== '') &&
        (p.path) && (p.path !== '') &&
        (typeof p.tls === 'boolean') &&
        (p.secret)) {
      return true;
    } else {
      return false;
    }
  }
}).

/**
 * factory: SH
 */
factory('SH', ['$rootScope', '$q', '$timeout', 'SockethubSettings', 'cQueue',
function ($rootScope, $q, $timeout, settings, cQueue) {
  var sc;
  var callbacks = {
    'error': {},
    'message': {},
    'response': {},
    'close': {},
    'registered': {},
    'connected': {}
  };

  function isConnected() {
    if (sc) {
      return sc.connected;
    } else {
      return false;
    }
  }

  function isRegistered() {
    if (sc) {
      return sc.registered;
    } else {
      return false;
    }
  }

  function callSH(job) {
    console.log('callSH called ', job);
    sc[job.methods[0]].apply(sc, job.params)
      .then(function (e) {
        $rootScope.$apply(function () {
          job.defer.resolve(e);
        });
      }, function (e) {
        $rootScope.$apply(function () {
          job.defer.reject(e.message);
        });
      });
  }
  var queue = cQueue.init(callSH);

  function connect(p) {
    console.log('ngSockethubClient.connect() ', p);
    var defer = $q.defer();
    var scheme = 'ws://';
    settings.connected = false;
    if (settings.conn.tls) {
      scheme = 'wss://';
    }

    var robj = {};
    if ((p) && (p.register)) {
      robj = {
        register: {
          secret: settings.conn.secret
        }
      };
    }

    console.log('SOCKEHTHUB CONNECT: '+scheme +
                                 settings.conn.host + ':' +
                                 settings.conn.port +
                                 settings.conn.path);

    sc = SockethubClient.connect(scheme +
                                 settings.conn.host + ':' +
                                 settings.conn.port +
                                 settings.conn.path,
                                 robj
    );

    sc.on('connected', function () { // connected
      console.log('Sockethub connected');
      settings.connected = true;
      if (callbacks['connected']['sockethub']) {
        $rootScope.$apply(callbacks['connected']['sockethub']());
      } else {
        $rootScope.$apply(function () {
          defer.resolve();
        });
      }
    });

    sc.on('registered', function () { // connected & registered
      console.log('Sockethub connected & registered');
      settings.connected = true;
      if (callbacks['registered']['sockethub']) {
        $rootScope.$apply(callbacks['registered']['sockethub']());
      } else {
        $rootScope.$apply(function () {
          defer.resolve();
        });
      }
    });

    sc.on('registration-failed', function (err) { // connected
      console.log('Sockethub register failed ', err);
      $rootScope.$apply(function () {
        defer.reject(err);
      });
    });

    sc.on('failed', function (err) { // connection failed
      console.log('Sockethub connection failed ', err);
      $rootScope.$apply(function () {
        defer.reject('Failed connecting to sockethub at ' + scheme +
                     settings.conn.host + ':' + settings.conn.port +
                     settings.conn.path);
      });
    });

    sc.on('disconnected', function (err) { // disconnected
      console.log('SH received disconnect(close) '+err);
      settings.connected = false;
    });

    sc.on('message', function (data) { // message
      if ((data.platform) &&
          (callbacks['message'][data.platform])) {
        console.log('SH passing message to platform: '+data.platform);
        $rootScope.$apply(callbacks['message'][data.platform](data));
      } else {
        console.log('SH received message with nothing to call: ', data);
      }
    });

    sc.on('unexpected-response', function (msg) {
      console.log('SH unexpected response: ', msg);
    });

    return defer.promise;
  }

  function register() {
    var defer = $q.defer();
    console.log('SH.register() called');
    queue.add({
      methods: ['register'],
      params: [{
        secret: settings.conn.secret
      }],
      defer: defer,
      timeout: 0,
      condition: isConnected
    });
    return defer.promise;
  }

  function sendSet(platform, type, index, object) {
    var defer = $q.defer();
    var data = {};
    data[type] = {};
    data[type][index] = object;
    queue.add({
      methods: ['set'],
      params: [platform, data],
      defer: defer,
      timeout: 0,
      condition: isRegistered
    });
    return defer.promise;
  }

  function callSubmit(obj, timeout) {
    var defer = $q.defer();
    queue.add({
      condition: isRegistered,
      methods: ['sendObject'],
      params: [obj, timeout],
      defer: defer,
      timeout: 0
    });
    return defer.promise;
  }

  function queueSubmit(obj, timeout) {
    queue.add({
      condition: isRegistered,
      methods: ['sendObject'],
      params: [obj, timeout],
      defer: false,
      timeout: 0
    });
  }

  var on = function on(platform, type, func) {
    callbacks[type][platform] = func;
  };

  return {
    connect: connect,
    register: register,
    isConnected: isConnected,
    isRegistered: isRegistered,
    set: sendSet,
    submit: {
      call: callSubmit,
      queue: queueSubmit
    },
    on: on
  };
}]).

/**
 * emitters
 */
run(['$rootScope',
function ($rootScope) {
  $rootScope.$on('showModalSockethubSettings', function(event, args) {
    backdrop_setting = true;
    if ((typeof args === 'object') && (typeof args.locked !== 'undefined')) {
      if (args.locked) {
        backdrop_setting = "static";
      }
    }
    $("#modalSockethubSettings").modal({
      show: true,
      keyboard: true,
      backdrop: backdrop_setting
    });
  });

  $rootScope.$on('closeModalSockethubSettings', function(event, args) {
    $("#modalSockethubSettings").modal('hide');
  });
}]).

directive('sockethubSettings', ['SH', '$rootScope', 'SockethubSettings',
function (SH, $rootScope, settings) {
  return {
    restrict: 'A',
    template: '<div id="modalSockethubSettings" class="modal fade">' +
              '<div class="modal-dialog"><div class="modal-content">' +
              '  <div class="modal-header" style="text-align:center;">' +
              '    <button type="button" class="close" data-dismiss="modal" aria-hidden="true">&times;</button>' +
              '    <img data-ng-src="{{ sockethub.settings.env.logo }}" width="200" ng-cloak/>' +
              '  </div>' +
              '  <div class="modal-body">' +
              '    <form name="settingsSockethub" role="form" novalidate>' +
              '      <fieldset>' +
              '        <div class="form-group">' +
              '          <label for="host">Hostname</label>' +
              '          <div class="controls">' +
              '            <input type="text" class="required form-control" name="host" placeholder="Enter hostname..." ng-model="sockethub.settings.conn.host" required>' +
              '          </div>' +
              '        </div>' +
              '        <div class="form-group">' +
              '          <label for="port">Port</label>' +
              '          <div class="controls">' +
              '            <input type="text" class="required form-control" name="port" placeholder="Enter port..." ng-model="sockethub.settings.conn.port" required>' +
              '          </div>' +
              '        </div>' +
              '        <div class="form-group">' +
              '          <label for="path">Path</label>' +
              '          <div class="controls">' +
              '            <input type="text" class="required form-control" name="path" placeholder="Enter path (if any)..." ng-model="sockethub.settings.conn.path">' +
              '          </div>' +
              '        </div>' +
              '        <div class="form-group">' +
              '          <label>' +
              '            <input type="checkbox" name="tls" ng-model="sockethub.settings.conn.tls"> TLS'+
              '          </label>' +
              '        </div>' +
              '        <div class="form-group">' +
              '          <label for="secret">Secret</label>' +
              '          <div class="controls">' +
              '            <input type="text" class="required form-control" name="secret" placeholder="Enter secret..." ng-model="sockethub.settings.conn.secret" required>' +
              '          </div>' +
              '        </div>' +
              '      </fieldset>' +
              '    <p></p>' +
              // '    <div class="message-container">' +
              // '      <div message></div>' +
              // '    </div>' +
              '  </div>' +
              '  <div class="modal-footer">' +
              '        <div class="control-group">' +
              '          <div class="controls">' +
              '            <button class="btn btn-primary" ng-click="sockethub.save(sockethub.settings.conn)" ' +
              '                    ng-disabled="!sockethub.settings.verify(\'conn\', sockethub.settings.conn) || saving">Submit</button>' +
              '          </div>' +
              '        </div>' +
              '    </form>' +
              '  </div>' +
              '</div></div>' +
              '</div>',
    link: function (scope) {
      scope.sockethub = {
        saving: false,
        settings: settings
      };
      scope.sockethub.save = function (cfg) {
        scope.sockethub.saving = true;
        /*$rootScope.$broadcast('message', {
              type: 'clear'
        });*/
        scope.sockethub.settings.save('conn', cfg);
        $rootScope.$broadcast('message', {
              message: 'attempting to connect to sockethub',
              type: 'info',
              timeout: false
        });
        SH.connect({register: true}).then(function () {
          scope.sockethub.saving = false;
          console.log('connected to sockethub');
          $rootScope.$broadcast('message', {
                message: 'connected to sockethub',
                type: 'success',
                timeout: true
          });
          $("#modalSockethubSettings").modal('hide');
        }, function (err) {
          scope.sockethub.saving = false;
          console.log('error connection to sockethub: ', err);
          $rootScope.$broadcast('message', {
                message: err,
                type: 'error',
                timeout: false
          });
        });
      };
    }
  };
}]);;angular.module('ngSockethubRemoteStorage', ['ngSockethubClient', 'ngRemoteStorage']).

/**
 * run
 */
run(['$rootScope', '$q', '$timeout', 'SockethubSettings', 'SH', 'RS',
function ($rootScope, $q, $timeout, settings, SH, RS) {
  SH.on('sockethub', 'registered', function () {
    // sockethub connected, save settings to RS
    console.log('Sockethub-RemoteStorage: saving sockethub config to remoteStorage ', settings.conn);
    RS.call('sockethub', 'writeConfig', [settings.conn]).then(function () {
      console.log('config saved to RS');
    }, function (err) {
      console.log('Sockethub-RemoteStorage: Failed saving sockethub config to remoteStorage: ',err);
      $rootScope.$broadcast('message', {
        message: 'failed saving sockethub config to remote storage',
        type: 'error',
        timeout: true
      });
    });
  });
}]).

factory('SockethubBootstrap', ['RS', 'SockethubSettings', '$rootScope', 'SH',
function (RS, settings, $rootScope, SH) {
  function run(defaultCfg) {
    RS.call('sockethub', 'getConfig', ['']).then(function (c) {
      console.log('GOT SH CONFIG: ', c);
      var cfg = {};
      if (!defaultCfg) {
        defaultCfg = {
          host: 'localhost',
          port: 10550,
          path: '/sockethub',
          tls: flse,
          secret: '1234567890'
        };
      }

      if ((typeof c !== 'object') || (typeof c.host !== 'string')) {
        //cfg = settings.conn;
        cfg = defaultCfg;
      } else {
        cfg = c;
      }

      console.log('USING SH CONFIG: ', cfg);
      //$rootScope.$broadcast('message', {type: 'clear'});
      // connect to sockethub and register
      if (settings.save('conn', cfg)) {
        $rootScope.$broadcast('message', {
              message: 'attempting to connect to sockethub',
              type: 'info',
              timeout: false
        });
        SH.connect({register: true}).then(function () {
          //console.log('connected to sockethub');
          $rootScope.$broadcast('message', {
                message: 'connected to sockethub',
                type: 'success',
                timeout: true
          });
        }, function (err) {
          console.log('error connecting to sockethub: ', err);
          $rootScope.$broadcast('SockethubConnectFailed', {message: err});
        });
      } else {
        $rootScope.$broadcast('message', {
              message: 'failed saving sockethub credentials',
              type: 'error',
              timeout: true
        });
      }
    }, function (err) {
      console.log("RS.call error: ",err);
    });
  }

  return {
    run: run
  };
}]);