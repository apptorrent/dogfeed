angular.module('dogfeed', [
    'ngFeeds',
    'ngSockethubClient',
    'ngSockethubRemoteStorage',
    'ngRemoteStorage',
    'ngMessages',
    'ngRoute'
]).

/**
 * routes
 */
config(['$routeProvider', '$locationProvider',
function ($routeProvider, $locationProvider) {
  $locationProvider.html5Mode(true);
  $routeProvider.
    when('/', {
      templateUrl: "main.html"
    }).
    when('/settings/sockethub', {
      templateUrl: "sockethub-settings.html"
    }).
    when('/feeds/add', {
      templateUrl: '/res/js/feeds/feed-add.html.tpl'
    }).
    when('/feeds/edit/:feed', {
      templateUrl: '/res/js/feeds/feed-edit.html.tpl'
    }).
    when('/feeds/:feed', {
      templateUrl: 'main.html'
    }).
    when('/about', {
      templateUrl: 'about.html'
    }).
    otherwise({
      redirectTo: "/"
    });
}]).

run(['$rootScope', '$timeout',
function ($rootScope, $timeout) {
  $rootScope.delayed = false;
  $timeout(function () {
    // give the app a second or two to load before we determine if the user
    // is logged in or not.
    $rootScope.delayed = true;
  }, 3000);
}]).

/**
 * snap.js initialization
 */
run(['$rootScope',
function ($rootScope) {
  $rootScope.snapper = new Snap({
    element: document.getElementById('content'),
    disable: 'right',
    maxPosition: 220
  });

  $(window).on('resize', function () {
      $rootScope.isMobile = matchMedia('(max-width:1024px)').matches;
      $rootScope.isDesktop = !$rootScope.isMobile;
  });

  $(window).on('resize', function () {
    if ($rootScope.isMobile) {
      //console.log("ENABLE SNAPPER ");
      $rootScope.snapperDisabled = false;
      $rootScope.snapper.enable();
    } else {
      //console.log("DISABLE SNAPPER ");
      $rootScope.snapperDisabled = true;
      $rootScope.snapper.close();
      $rootScope.snapper.disable();
    }
  });
}]).

/**
 * remotestorage config
 */
run(['RemoteStorageConfig',
function (RScfg) {
  RScfg.modules = [
    ['sockethub', 'rw', {'cache': false}],
    ['feeds', 'rw', {'cache': false}],
    ['articles', 'rw', {'cache': false}]
  ];
}]).

/**
 * messages config
 */
run(['MessagesConfig',
function (cfg) {
  cfg.timeout = 15000;
}]).

/**
 * get sockethub settings and try to connect
 */
run(['SockethubBootstrap',
function (SockethubBootstrap) {
  SockethubBootstrap.run({
    // default connection settings, if none found in remoteStorage
    host: 'silverbucket.net',
    port: '443',
    path: '/sockethub',
    tls: true,
    secret: '1234567890'
  });
}]).

/**
 * remoteStorage
 */
run(['$rootScope', 'RS', '$timeout',
function ($rootScope, RS, $timeout) {
  if (!RS.isConnected()) {
    $timeout(function () {
      if (!RS.isConnected()) {
        $rootScope.$broadcast('message', {message: 'remotestorage-connect', timeout: false});
      }
    }, 3000);
  }
}]).

/**
 * listeners/emitters
 */
run(['$rootScope', '$location',
function ($rootScope, $location) {
  $rootScope.$on('sockethubSettingsSaved', function() {
    $location.path('/');
  });
}]).

/**
 * filter: fromNow (date)
 */
filter('fromNow', [
function() {
  return function (dateString) {
    return new Date(dateString).toDateString(); ///moment(new Date(dateString)).fromNow();
  };
}]).

/**
 * filter: pagination
 */
filter('pagination', [
function() {
  var count = 0;
  var max = 3;
  return function (article) {
    console.log("pagination received: ", article);
    if (!article) { return false; }
    count = count + 1;
    if (count > 10) {
      console.log('pagination returned false');
      return false;
    }
    console.log('pagination returned article: ',article);
    return article;
  };
}]).

///////////////////////////////////////////////////////////////////////////
//
// CONTROLLERS
//
///////////////////////////////////////////////////////////////////////////

/**
 * controller: titlebarCtrl
 */
controller('titlebarCtrl',
['$scope', '$rootScope', 'SockethubSettings', 'RS',
function ($scope, $rootScope, settings, RS) {

  $scope.showFeedList = function () {
    if ($rootScope.snapper.state().state === "left") {
      $rootScope.snapper.close();
    } else {
      $rootScope.snapper.open('left');
    }
  };

  $scope.$watch('settings.connected', function (newVal, oldVal) {
    if (settings.connected) {
      settings.conn.port = Number(settings.conn.port);
      RS.call('sockethub', 'writeConfig', [settings.conn]).then(function () {
        console.log("Sockethub config saved to remoteStorage");
      }, function (err) {
        console.log('Failed saving Sockethub config to remoteStorage: ', err);
      });
    }
  });
}]).

controller('mainCtrl', ['$scope', 'RS', 'SH', '$timeout', '$rootScope', '$routeParams',
function ($scope, RS, SH, $timeout, $rootScope, $routeParams) {
console.log("mainCtrl ROUTE PARAMS: ", $routeParams);
  $scope.isConnected = function () {
//console.log('isConnected: ['+RS.isConnected()+'] ['+SH.isConnected()+']');
    if ((RS.isConnected()) && (SH.isConnected())) {
      return true;
    } else {
      if (($routeParams.feed) && (SH.isConnected())) {
        return true;
      } else {
        return false;
      }
    }
  };

  $scope.isConnecting = function () {
//console.log('isConnecting: ['+RS.isConnected()+'] ['+SH.isConnected()+']');
    if ((RS.isConnecting()) || (SH.isConnecting())) {
      return true;
    } else {
      return false;
    }
  };

  $scope.delayed = function () {
    return $rootScope.delayed;
  };

}]).

directive('loading', [
function () {
  return {
    restrict: 'E',
    templateUrl: 'loading.html'
  };
}]).

directive('welcome', [
function () {
  return {
    restrict: 'E',
    templateUrl: 'welcome.html'
  };
}]).

directive('about', [
function () {
  return {
    restrict: 'E',
    templateUrl: 'about.html'
  };
}]);;angular.module('ngFeeds', ['ngRemoteStorage', 'ngSockethubClient', 'ngSanitize']).


/**
 * settings service
 */
value('configHelper', {
  exists: function exists(config, cfg) {
    if (!cfg) {
      cfg = config;
    }

    for (var key in config) {
      if (!cfg[key]) {
        return false;
      }
    }
    return true;
  },
  set: function (config, cfg) {
    for (var key in cfg) {
      config[key] = cfg[key];
    }
    return config;
  }
}).

run(['$routeParams', '$rootScope', 'Feeds',
function ($routeParams, $rootScope, Feeds) {

  $rootScope.feeds = Feeds.data;

}]).


///////////////////////////////////////////////////////////////////////////
//
// FACTORY
//
///////////////////////////////////////////////////////////////////////////

/**
 * Factory: Feeds
 */
factory('Feeds', ['$q', 'SH', 'configHelper', 'RS', '$rootScope',
function ($q, SH, CH, RS, $rootScope) {

  var config = {};
  var data = {
    articles: [],
    info: {},
    infoArray: [],
    groups: {},
    groupArray: [],
    settings: {
      showRead: true,  // show read articles or disappear them
      articlesPerPage: 10,  // number of articles to show per page
      displayCap: 5,  // current limit of articles to show (increments by articlesPerPage)
      displayed: {}  // index of displayed articles
    },
    current: {
      name: '',
      indexes: []
    },
    edit: {
      name: '',
      url: '',
      origName: ''
    }
  };
  var func = {};

  /****
   * CONFIG MANAGEMENT
   ********************/
  function exists(cfg) {
    return CH.exists(config, cfg);
  }

  func.setConfig = function set(cfg) {
    var defer = $q.defer();
    if (exists(cfg)) {
      if (cfg) {
        CH.set(config, cfg);
      }
      defer.resolve(config);
    } else {
      defer.reject('config not set correctly');
    }
    return defer.promise;
  };

  /****
   * ARTICLE MANAGEMENT
   *********************/
  // update or create an article entry on remoteStorage
  func.updateArticle = function updateArticle(obj) {
    var defer = $q.defer();
    var s_obj = {
      link: obj.object.link,
      title: obj.object.title,
      date: obj.object.date,
      html: obj.object.html,
      text: obj.object.text,
      brief_html: obj.object.brief_html,
      brief_text: obj.object.brief_text,
      read: (obj.object.read) ? true : false,
      source_link: obj.actor.address,
      source_title: obj.actor.name
    };

    RS.call('articles', 'update', [s_obj]).then(function (m) {
      //console.log('article added: ', m);
      //data.info[obj.url] = obj;
      //func.fetchFeed(obj.url);
      defer.resolve(m);
    }, function (err) {
      defer.reject(err);
    });
    return defer.promise;
  };

  /****
   * FEED MANAGEMENT
   ******************/
  // grab whatever feeds exists in remoteStorage right away
  (function getFeedUrls() {
    RS.call('feeds', 'getAll', ['']).then(function (urls) {
      console.log('Feeds: got feed urls from remoteStorage ', urls);
      for (var key in urls) {
        if ((!urls[key]) || (typeof urls[key].url === 'undefined')) {
          console.log('ERROR processing url['+key+']: ', urls[key]);
        } else {
          var url = urls[key].url;
          urls[key].unread = 0;
          func.fetchFeed(urls[key].url); // asign existing feed info to data struct
        }
      }
    }, function (err) {
      console.log('error: unable to get feed list from remoteStorage: ', err);
      $rootScope.$broadcast('message', {
        message: 'unable to get feed list from remotestorage',
        type: 'error',
        timeout: false
      });
    });
  })();

  /**
   * Function: addFeed
   *
   * take a record from sockethub and creates a feed entry, queueing to store
   * in rs
   *
   * Parameters:
   *
   *   url - url of feed
   *   name - optional name of feed
   *
   */
  function addFeed (url, name) {
    var obj = {
      url: url,
      name: name,
      cache_articles: 20,
      last_fetched: new Date().getTime(),
      unread: 0
    };
    data.info[obj.url] = obj;
    data.infoArray.push(obj);
    RS.queue('feeds', 'add', [obj]);
  }

  /**
   * Function: updateFeed
   *
   * update feed with the passed in feed object
   *
   * Parameters:
   *
   *   obj - feed object (remotestorage format)
   */
  func.updateFeed = function (obj) {
    //console.log('updateFeed called', obj);
    var updated = false;
    for (var i = 0, len = data.infoArray.length; i < len; i = i + 1) {
      console.log("infoArray "+i+': '+ data.infoArray[i].url + ' === '+ obj.url);
      if ((data.infoArray[i]) && (data.infoArray[i].url === obj.url)) {
        //console.log("MATCH");
        data.infoArray[i].name = obj.name;
        data.info[obj.url].name = obj.name;
        updated = true;
        break;
      } else {
        //console.log(" NO MATCH");
      }
    }
    //console.log(" UPDATED "+updated);
    if (!updated) {
      addFeed(obj.url, obj.name);
    } else {
      RS.call('feeds', 'add', [data.info[obj.url]]).then(function (m) {
        console.log('feed updated: ', data.info[obj.url]);
        $rootScope.$broadcast('message', {type: 'success', message: 'updated feed ' + obj.url});
      }, function (err) {
        console.log('ERROR',err);
        $rootScope.$broadcast('message', {type: 'error', message: err.message});
      });
    }
  };

  /**
   * Function: removeFeed
   *
   * remove a feed from the feed lists and remotestorage
   *
   * Parameters:
   *
   *   url - feed url
   */
  func.removeFeed = function (url) {
    var defer = $q.defer();
    RS.call('feeds', 'remove', [url]).then(function (m) {
      delete data.info[url];
      for (var i = 0, len = data.infoArray.length; i < len; i = i + 1) {
        if ((data.infoArray[i]) && (data.infoArray[i].url === url)) {
          //console.log('removing from list: ',data.infoArray[i]);
          data.infoArray.splice(i, 1);
          break;
        }
      }
      console.log('articles count: '+data.articles.length);
      for (i = 0, len = data.articles.length; i < len; i = i + 1) {
        if ((data.articles[i]) && (data.articles[i].actor.address === url)) {
          //console.log('removing article from list: ',data.articles[i]);
          data.articles.splice(i, 1);
        }
      }
      console.log('articles count: '+data.articles.length);
      console.log('feed removed: ', url);
      defer.resolve(m);
    }, function (err) {
      defer.reject(err);
    });
    return defer.promise;
  };

  /****
   * FEED FETCHING
   ****************/
  var feedsTried = {};
  // issue orders to fetch feeds from sockethub
  func.fetchFeed = function fetch(url) {
    var match = false;
    for (var i = 0, len = data.infoArray.length; i < len; i = i + 1) {
      if ((data.infoArray[i]) && (data.infoArray[i].url === url)) {
        match = true;
        break;
      }
    }
    if ((match) || (feedsTried[url])) {
      return;
    }
    feedsTried[url] = true;
    var msg = {
      verb: 'fetch',
      platform: 'rss',
      actor: {
        address: 'rss'
      },
      target: [{
        address: url
      }]
    };
    //console.log("FETCH: ", msg);
    var defer = $q.defer();
    $rootScope.$broadcast('message', {type: 'info', message: 'attempting to fetch feed '+url});
    SH.submit.call(msg).then(function (o) {
      $rootScope.$broadcast('message', {type: 'success', message: 'feed added '+url});
      data.info[url]['loaded'] = true;
      defer.resolve();
    }, function (e) {
      console.log('failed fetch');
      $rootScope.$broadcast('message', {
        message: 'failed fetching feed: '+e,
        type: 'error'
      });
      defer.reject(e);
    });
    return defer.promise;
  };

  //
  //
  // detect when new articles are received from Sockethub
  SH.on('rss', 'message', function (m) {
    console.log("Feeds received message ",m);
    var key = m.actor.address;
    if (!m.status) {
      console.log('received error message from sockethub: ', m);
      $rootScope.$broadcast('message', {
        type: 'error',
        message: m.target[0].address + ' ' + m.message
      });
      return;
    }

    // check if the feed entry for this article exists yet, if not add it.
    // also check to update name.
    if (!data.info[key]) {
      console.log('#### - adding to data.info: ',m);
      addFeed(m.actor.address, m.actor.name);
    } else if ((!data.info[key].name) || (data.info[key].name === data.info[key].url)) {
      console.log('#### - updating name: ',m);
      data.info[key]['name'] = m.actor.name;
    }

    if (!m.object.read) {
      m.object.read = false;
      data.info[key].unread = (typeof data.info[key].unread === "number") ? data.info[key].unread + 1 : 1;
    }

    // add article to article list
    data.articles.push(m);

    // fetch article from remoteStorage if exists
    RS.call('articles', 'getByUrl', [m.object.link]).then(function (a) {
      if (a) {
        //console.log('ARTICLE FETCH from RS: ', a);
        m.object.read = (a.read) ? a.read : false;
      }

      if (m.object.read) {
        // this article is read, subtract from total
        data.info[key].unread = (typeof data.info[key].unread === "number") ? data.info[key].unread - 1 : 0;
      }
    }, function (e) {
      console.log("ARTICLE FETCH ERROR: ", e);
    });
  });

  return {
    config: config,
    data: data,
    func: func
  };
}]).


///////////////////////////////////////////////////////////////////////////
//
// CONTROLLERS
//
///////////////////////////////////////////////////////////////////////////

/**
 * controller: addFeedCtrl
 */
controller('addFeedCtrl',
['$scope', 'Feeds', '$location',
function ($scope, Feeds, $location) {
  $scope.adding = false;

  $scope.add = function (url) {
    $scope.adding = true;
    Feeds.func.fetchFeed(url).then(function () {
      $scope.adding = false;
      $location.path('/feed/'+url);
    }, function (e) {
      $scope.adding = false;
    });
  };

}]).

/**
 * controller: feedSettingsCtrl
 */
controller('feedSettingsCtrl',
['$scope', 'Feeds', '$rootScope', '$routeParams', '$location',
function ($scope, Feeds, $rootScope, $routeParams, $location) {
  $scope.saving = false;
  $scope.feeds = Feeds.data;
  var feedUrl;
  if ($routeParams.feed) {
    feedUrl = decodeURIComponent($routeParams.feed);
    console.log('feedSettingsCtrl feedUrl: '+feedUrl, Feeds.data.info);
    Feeds.data.edit.url = feedUrl;
    Feeds.data.edit.name = Feeds.data.info[feedUrl].name;
    Feeds.data.edit.origName = Feeds.data.info[feedUrl].name;
  } else {
    $location.path('/feeds/');
  }

  $scope.saveFeedSettings = function (feed) {
    $scope.saving = true;
    console.log('saveFeed', feed);
    delete feed.origName;
    Feeds.func.updateFeed(feed);
    $scope.saving = false;
    $location.path('/feeds/'+feedUrl);
  };

  $scope.cancelFeedSettings = function () {
    console.log('CANCEL: '+feedUrl, $scope.feeds.edit);
    Feeds.data.info[feedUrl].name = Feeds.data.edit.origName;
    $scope.saving = false;
    $location.path('/feeds/'+$routeParams.feed);
  };

  $scope.deleteFeed = function (feed) {
    $scope.saving = true;
    Feeds.func.removeFeed(feed.url).then(function () {
      $rootScope.$broadcast('message', {type: 'success', message: 'deleted feed '+feed.url});
      $scope.saving = false;
      $location.path('/feeds/');
    }, function (err) {
      console.log('error removing rss feed!: ', err);
      $rootScope.$broadcast('message', {type: 'error', message: err.message});
      $scope.saving = false;
      $location.path('/feeds/');
    });
  };

}]).

/**
 * controller: feedCtrl
 */
controller('feedCtrl',
['$scope', 'Feeds', '$rootScope', '$timeout', '$routeParams',
function ($scope, Feeds, $rootScope, $timeout, $routeParams) {
  //console.log('--- feedCtrl ' + $routeParams.feed);
  $scope.saving = false;

  if ($routeParams.feed) {
    var feed = decodeURIComponent($routeParams.feed);
    console.log("FEED PARAM: "+feed);
    // if we have a url as a param, we try to fetch it

    //Feeds.data.selectedFeed = feed;
    Feeds.data.current.name = (Feeds.data.info[feed]) ? Feeds.data.info[feed].name : feed;
    Feeds.data.current.id = feed;
    Feeds.data.current.indexes = [feed];
    if (!Feeds.data.info[feed]) {
      $rootScope.$broadcast('message', {
        message: 'attempting to fetch feed from '+feed,
        type: 'info'
      });
      Feeds.func.fetchFeed(feed);
    }
  } else {
    Feeds.data.current.name = '';
    Feeds.data.current.indexes.length = 0;
  }

  $rootScope.$on('SockethubConnectFailed', function (event, e) {
    console.log('Sockethub connect failed! ', e);
    $rootScope.$broadcast('message', {
      message: e.message,
      type: 'error',
      timeout: false
    });
    //$scope.model.loading = true;
    $rootScope.$broadcast('showModalSockethubSettings', {locked: false});
  });
}]).


///////////////////////////////////////////////////////////////////////////
//
// DIRECTIVES
//
///////////////////////////////////////////////////////////////////////////

factory('isSelected', ['Feeds',
function (Feeds) {
  return function (url, inclusive) {
    if (Feeds.data.current.indexes.length === 0) {
      if ((inclusive) || (!url)) {
        return true;
      } else {
        return false;
      }
    } else {
      for (var i = 0, num = Feeds.data.current.indexes.length; i < num; i = i + 1) {
        if (Feeds.data.current.indexes[i] === url) {
          return true;
        }
      }
    }
    return false;
  };
}]).

/**
 * directive: feedList
 */
directive('feedList', ['isSelected', 'Feeds', '$location', '$rootScope',
function (isSelected, Feeds, $location, $rootScope) {
  function FeedListCtrl ($scope) {

    $scope.isSelected = isSelected;

    $scope.switchFeed = function (url, groupId, error) {
      //console.log('SWITCH FEED: '+encodeURIComponent(url));
      if (error) { return false; }
      if (!url) {
        $location.path('/feeds/');
      } else {
        $location.path('/feeds/'+encodeURIComponent(url));
      }
      $rootScope.snapper.close();
    };
  }

  return {
    restrict: 'E',
    scope: {
      'feeds': '=',
      'settings': '=',
      'test': '='
    },
    templateUrl: '/res/js/feeds/feed-list.html.tpl',
    controller: FeedListCtrl,
    transclude: true
  };
}]).

/**
 * directive: articles
 */
directive('articles', ['isSelected', 'Feeds', '$location',
function (isSelected, Feeds, $location) {
  function ArticlesCtrl($scope) {

    $scope.showFeedSettings = function (url) {
      console.log('showFeedSettings: '+url);
      if (!url) {
        return;
      } else {
        $location.path('/feeds/edit/'+encodeURIComponent(url));
      }
    };

    // returns true if current selection is empty (has no unread articles)
    $scope.currentIsEmpty = function () {
      if (!$scope.feeds.current.name) {
        return false;
      }
      for (var i = 0, num = $scope.feeds.current.indexes.length; i < num; i = i + 1) {
        //console.log('checking '+$scope.model.feeds.current.indexes[i], $scope.model.feeds.info[$scope.model.feeds.current.indexes[i]]);
        if ((Feeds.data.info[Feeds.data.current.indexes[i]]) &&
            (Feeds.data.info[Feeds.data.current.indexes[i]].unread > 0)) {
          return false;
        }
        if (Feeds.data.settings.showRead) {
          return false;
        }
      }
      return true;
    };

    $scope.markRead = function (a, idx) {
      //console.log('markRead Called!',idx);
      if (!a.object.read) {
        //console.log('subtracting 1 from : '+ Feeds.data.info[a.actor.address].unread);
        Feeds.data.info[a.actor.address].unread =
            Feeds.data.info[a.actor.address].unread - 1;
        a.object.read = true;
        if (typeof idx === 'number') {
          $('#article'+idx).collapse('hide');
        }
      } else if (a.object.read) {
        //console.log('adding 1 to : '+ Feeds.data.info[a.actor.address].unread);
        Feeds.data.info[a.actor.address].unread =
            Feeds.data.info[a.actor.address].unread + 1;
        a.object.read = false;
      }
      Feeds.func.updateArticle(a);
    };

    $scope.isShowable = function (article) {
      if (!isSelected(article.actor.address, true)) {
        return false;
      }

      if (article.object.read) {
        if (Feeds.data.settings.showRead) {
          Feeds.data.settings.displayed[article.object.link] = true;
          return true;
        } else {
          return false;
        }
      } else {
        Feeds.data.settings.displayed[article.object.link] = true;
        return true;
      }

      if (Feeds.data.settings.displayed[article.object.link]) {
        return true;
      }

      if (Object.keys(Feeds.data.settings.displayed).length >= Feeds.data.settings.displayCap) {
        return false;
      }
    };
  }

  return {
    restrict: 'E',
    scope: {
      'feeds': '=',
      'settings': '='
    },
    controller: ArticlesCtrl,
    templateUrl: '/res/js/feeds/articles.html.tpl',
    link: function (scope, element, attrs) {
      var divs = document.getElementsByClassName('article');
      for (var i = 0, num = divs.length; i < num; i = i + 1) {
        // grab all of the links inside the div
        var links = divs[i].getElementsByTagName('a');
        // Loop through those links and attach the target attribute
        for (var j = 0, jnum = links.length; j < jnum; j = j + 1) {
          // the _blank will make the link open in new window
          links[j].setAttribute('target', '_blank');
        }
      }
    }
  };
}]);;angular.module('ngRemoteStorage', ['ngCommandQueue']).

value('RemoteStorageConfig', {
  modules: []
}).

factory('RS', ['$rootScope', '$q', '$timeout', 'cQueue',
function ($rootScope, $q, $timeout, cQueue) {

  var ready = false;
  var connecting = false;

  function isConnected() {
    return remoteStorage.remote.connected;
  }

  function isConnecting() {
    return connecting;
  }

  remoteStorage.on('ready', function () {
    ready = true;
    connecting = false;
  });
  remoteStorage.on('connecting', function () {
    ready = false;
    connecting = true;
  });
  remoteStorage.on('authing', function () {
    connecting = true;
    ready = false;
  });
  remoteStorage.on('disconnected', function () {
    connecting = false;
    ready = true;
  });

  function callRS(job) {
    //console.log('callRS:', job);
    remoteStorage[job.methods[0]][job.methods[1]].apply(null, job.params).
      then(function (res) {
        $rootScope.$apply(function () {
          if (job.defer) {
            job.defer.resolve(res);
          }
        });
      }, function (err) {
        $rootScope.$apply(function () {
          if (job.defer) {
            job.defer.reject(err);
          } else {
            throw new Error(err);
          }

        });
      });
  }

  var queue = cQueue.init(callRS);

  return {
    isConnected: isConnected,
    isConnecting: isConnecting,
    queue: function (module, func, params) {
      console.log('RS.queue(' + module + ', ' + func + ', params):', params);
      queue.add({
        methods: [module, func],
        params: params,
        defer: false,
        timeout: 0,
        condition: isConnected
      });
    },
    call: function (module, func, params, failTimeout) {
      var defer = $q.defer();
      console.log('RS.call(' + module + ', ' + func + ', params):', params);
      if ((typeof params === 'object') &&
          (typeof params[0] === 'undefined')) {
        defer.reject('RS.call params must be an array');
      } else {
        // put request onto queue
        queue.add({
          methods: [module, func],
          params: params,
          defer: defer,
          timeout: failTimeout,
          condition: isConnected
        });
      }
      return defer.promise;
    }
  };
}]).


controller('remoteStorageCtrl',
['RemoteStorageConfig', '$scope',
function (RScfg, $scope) {
  remoteStorage.disableLog();

  $scope.$watch('RScfg.modules', function () {
    console.log('remoteStorageCtrl initializing modules: ', RScfg.modules);

    var mod, key;
    for (key in RScfg.modules) {
      mod = RScfg.modules[key];
      console.log('claim: '+mod[0]+ ' a: '+mod[1]);
      remoteStorage.access.claim(mod[0], mod[1]);
      if ((mod[2]) && (typeof mod[2].cache === 'boolean') && (!mod[2].cache)) {
        // disable caching
        remoteStorage.caching.disable('/'+mod[0]+'/');
      }
    }

    remoteStorage.displayWidget('remotestorage-connect', {
      redirectUri: window.location.protocol + '//' + window.location.host + '/rscallback.html'
    });

    for (key in RScfg.modules) {
      mod = RScfg.modules[key];
      if ((remoteStorage[mod[0]]) && (typeof remoteStorage[mod[0]].init === 'function')) {
        remoteStorage[mod[0]].init();
      }
    }
  });

}]);
;angular.module('ngCommandQueue', []).

factory('cQueue', ['$q', '$timeout',
function ($q, $timeout) {


  function cq(executeFunc, DEBUG) {
    /**
     * Variable: queue
     *
     * example structure:
     * {
     *   methods: (array)   // example: ['rss', 'add']
     *   params: (array),
     *   condition: (function),
     *   defer: (object),
     *   timeout: (number)
     * }
     */
    var queue = [];
    var setTimedCheck = false;
    var interval = 1000;
    var throttle = 250;

    function propertyCheck(e) {
      var defer = $q.defer();
      try {
        if ((typeof e.methods !== 'object') ||
            (typeof e.methods[0] === 'undefined')) {
          console.error('methods property must be an array, indicating function order from left to right');
          defer.reject();
        } else if ((typeof e.params !== 'object') ||
                   (typeof e.params[0] === 'undefined')) {
          console.error('params property must be an array, indicating parameter order from left to right');
          defer.reject();
        } else if (typeof e.condition !== 'function') {
          e.condition = function () { return true; };
        } else if (typeof e.defer !== 'object') {
          e.defer = false;
        } else if (typeof e.timeout !== 'number') {
          e.timeout = 0;
        }
        e.age = 0;
        defer.resolve(e);
      } catch (error) {
        defer.reject(error);
      }
      return defer.promise;
    }

    function pushToQueue(e) {
      return propertyCheck(e).then(function (e) {
        if (DEBUG) { console.log('adding to queue: '+e.methods.join(' - ')); }
        e.id = Math.random(0, 9) * 100 / Math.random(0, 9);
        queue.push(e);
        setTimedCheck = true;
      });
    }

    function procSingleEntry() {
      if (queue.length <= 0) {
        setTimedCheck = false;
        return;
      }

      for (var i in queue) {
        // get entry off queue;
        var e = queue[i];
        if (!e.condition()) {
          if (DEBUG) { console.log(' procSingleEntry, condition NOT met. ',queue[i]); }
          break;
        }
        if (DEBUG) { console.log(' procSingleEntry, condition met ['+queue[i].id+']. ',queue[i]); }
        queue.splice(i, 1);
        try {
          executeFunc(e);
        } catch (error) {
          console.log('error : ', error);
          console.log(error.stack);
          e.promise.reject(error);
        }
        break;
      }
      return;
    }

    (function procNextTick() {
      var i = 0;
      if (setTimedCheck) {
        // process a single entry from the queue every 'throttle' ms
        for (i in queue) {
          if ((queue[i].timeout !== 0) &&
              (queue[i].timeout < queue[i].age)) {
            if (DEBUG) { console.log('timing out ' + queue[i].methods.join('] [')); }
            queue[i].defer.reject('timed out');
            queue.splice(i, 1);
          } else {
            queue[i].age = queue[i].age + interval;
          }
        }
        $timeout(procSingleEntry, throttle);
      }

      $timeout(procNextTick, interval);
    })();

    return {
      add: pushToQueue
    };
  }

  return {
    init: function (executeFunc, DEBUG) {
      if (typeof executeFunc !== 'function') {
        throw new Error('cQueue init must pass a function to call when an entry from the queue is ready. The function should take the queue object as its first param');
      }
      return new cq(executeFunc, DEBUG);
    }
  };
}]);;angular.module('ngMessages', []).

value('MessagesConfig', {
  timeout: 4000
}).

directive('message',
['$rootScope', '$timeout', 'MessagesConfig',
function ($rootScope, $timeout, cfg) {
  return {
    restrict: 'A',
    template: '<div class="alert alert-{{ m.type }}" ng-show="haveMessage">'+
              '  <strong>{{m.title}}</strong> ' +
              '  <span>{{m.message}}</span>' +
              '</div>',
    link: function (scope) {
      scope.haveMessage = false;
      scope.m = {type: '', title: '', message: ''};

      var presets = {
        'remotestorage-connect': {
          type: 'warning',
          title : 'Connect to remoteStorage',
          message: 'if you want your changes to persist'
        },
        'sockethub-config': {
          type: 'warning',
          title: 'Sockethub configuration needed',
          message: 'You must fill in your Sockethub connection details'
        },
        'sockethub-connect': {
          type: 'danger',
          title: 'Sockethub connection error',
          message: 'Unable to connect to Sockethub please check your configuration and try again'
        },
        'sockethub-register': {
          type: 'danger',
          title: 'Sockethub registration problem',
          message: 'We were unable to register with your Sockethub instance'
        },
        'xmpp-connect': {
          type: 'danger',
          title: 'XMPP connection failed',
          message: 'There was a problem connecting to the XMPP server, please verify you settings'
        },
        'unknown': {
          type: 'danger',
          title: 'An unknown error has occurred',
          message: ''
        }
      };

      $rootScope.$on('message', function (event, e) {
        //console.log('message event: ', e);

        var timeout = (typeof e.timeout === 'boolean') ? e.timeout : true;
        scope.haveMessage = false;

        if (typeof e === 'undefined') {
          e = 'no error specified';
        }

        if (e.type === 'clear') {
          scope.haveMessage = false;
          scope.m = {type: '', title: '', message: ''};
          return;
        } else if (typeof presets[e.message] !== 'undefined') {
          scope.m = presets[e.message];
        } else if (typeof e.message === 'string') {
          if (e.type === 'success') {
            scope.m.title = 'Success';
          } else if (e.type === 'info') {
            scope.m.title = 'Info';
          } else {
            scope.m.title = "Error";
            e.type = 'danger';
          }
          scope.m.message = e.message;
          scope.m.type = e.type;
        }
        scope.m.timeout = timeout;
        //console.log('info message event set: ', scope.m);
        var message = scope.m.message;
        scope.haveMessage = true;
        if (timeout) {
          $timeout(function () {
            if ((scope.m.timeout) && (message == scope.m.message)) {
              scope.haveMessage = false;
              scope.m = {type: '', title: '', message: '', timeout: true};
            }
          }, cfg.timeout);
        }
      });
    }
  };
}]);
;angular.module('ngSockethubClient', ['ngCommandQueue']).

/**
 * default settings
 */
value('SockethubSettings', {
  conn: {
    host: 'localhost',
    port: 10550,
    path: '/sockethub',
    tls: false,
    secret: '1234567890'
  },
  connected: false,
  connecting: false,
  registered: false,
  env: {
    logo: '/res/img/sockethub-logo.svg'
  },
  save: function (prop, obj) {
    if (this.verify(prop, obj)) {
      this[prop] = obj;
      this[prop].port = +obj.port;
      console.log('SH SAVE [' + prop + ']: ', this[prop]);
      return true;
    } else {
      console.log('SH SAVE FAILED '+prop+': ', this[prop]);
      return false;
    }
  },
  exists: function (prop) {
    this.verify(prop, settings.conn);
  },
  verify: function (prop, p) {
    if (!p) {
      p = this[prop];
    }
    if ((p.host) && (p.host !== '') &&
        (p.port) && (p.port !== '') &&
        (p.path) && (p.path !== '') &&
        (typeof p.tls === 'boolean') &&
        (p.secret)) {
      return true;
    } else {
      return false;
    }
  }
}).

/**
 * factory: SH
 */
factory('SH', ['$rootScope', '$q', '$timeout', 'SockethubSettings', 'cQueue',
function ($rootScope, $q, $timeout, settings, cQueue) {
  var sc;
  var callbacks = {
    'error': {},
    'message': {},
    'response': {},
    'close': {},
    'registered': {},
    'connected': {}
  };


  function isConnected() {
    if ((settings.connected) && (settings.registered)) {
      return true;
    } else {
      return false;
    }
  }

  function isConnecting() {
    return settings.connecting;
  }

  function isRegistered() {
    return settings.registered;
  }

  function callSH(job) {
    console.log('callSH called ', job);
    sc[job.methods[0]].apply(sc, job.params)
      .then(function (e) {
        $rootScope.$apply(function () {
          job.defer.resolve(e);
        });
      }, function (e) {
        $rootScope.$apply(function () {
          job.defer.reject(e.message);
        });
      });
  }
  var queue = cQueue.init(callSH);

  function connect(p) {
    console.log('ngSockethubClient.connect() ', p);
    settings.connecting = true;
    settings.registered = false;
    settings.connected = false;
    var defer = $q.defer();
    var scheme = 'ws://';
    settings.connected = false;
    if (settings.conn.tls) {
      scheme = 'wss://';
    }

    var robj = {};
    if ((p) && (p.register)) {
      robj = {
        register: {
          secret: settings.conn.secret
        }
      };
    }

    console.log('Sockethub connect: '+scheme +
                                 settings.conn.host + ':' +
                                 settings.conn.port +
                                 settings.conn.path + ' register:'+ typeof robj.register);

    sc = SockethubClient.connect(scheme +
                                 settings.conn.host + ':' +
                                 settings.conn.port +
                                 settings.conn.path,
                                 robj
    );

    sc.on('connected', function () { // connected
      console.log('Sockethub connected');
      if (callbacks['connected']['sockethub']) {
        $rootScope.$apply(callbacks['connected']['sockethub']());
      } else {
        if (!p.register) {
          settings.connected = true;
          settings.connecting = false;
          // don't resolve the promise yet unless register was not requested
          // at the same time as connect
          $rootScope.$apply(function () {
            defer.resolve();
          });
        }
      }
    });

    sc.on('registered', function () { // connected & registered
      console.log('Sockethub connected & registered');
      settings.connected = true;
      settings.connecting = false;
      settings.registered = true;
      if (callbacks['registered']['sockethub']) {
        $rootScope.$apply(callbacks['registered']['sockethub']());
      } else {
        $rootScope.$apply(function () {
          defer.resolve();
        });
      }
    });

    sc.on('registration-failed', function (err) { // connected
      settings.registered = false;
      settings.connecting = false;
      console.log('Sockethub register failed ', err);
      $rootScope.$apply(function () {
        defer.reject(err);
      });
    });

    sc.on('failed', function (err) { // connection failed
      settings.registered = false;
      settings.connecting = false;
      settings.connected = false;
      console.log('Sockethub connection failed ', err);
      $rootScope.$apply(function () {
        defer.reject('Failed connecting to sockethub at ' + scheme +
                     settings.conn.host + ':' + settings.conn.port +
                     settings.conn.path);
      });
    });

    sc.on('disconnected', function (err) { // disconnected
      settings.registered = false;
      settings.connecting = false;
      settings.connected = false;
      console.log('SH received disconnect(close) '+err);
    });

    sc.on('message', function (data) { // message
      if ((data.platform) &&
          (callbacks['message'][data.platform])) {
        console.log('SH passing message to platform: '+data.platform);
        $rootScope.$apply(callbacks['message'][data.platform](data));
      } else {
        console.log('SH received message with nothing to call: ', data);
      }
    });

    sc.on('unexpected-response', function (msg) {
      console.log('SH unexpected response: ', msg);
    });

    return defer.promise;
  }

  function register() {
    var defer = $q.defer();
    console.log('SH.register() called');
    queue.add({
      methods: ['register'],
      params: [{
        secret: settings.conn.secret
      }],
      defer: defer,
      timeout: 0,
      condition: isConnected
    });
    return defer.promise;
  }

  function sendSet(platform, type, index, object) {
    var defer = $q.defer();
    var data = {};
    data[type] = {};
    data[type][index] = object;
    queue.add({
      methods: ['set'],
      params: [platform, data],
      defer: defer,
      timeout: 0,
      condition: isRegistered
    });
    return defer.promise;
  }

  function callSubmit(obj, timeout) {
    var defer = $q.defer();
    queue.add({
      condition: isRegistered,
      methods: ['sendObject'],
      params: [obj, timeout],
      defer: defer,
      timeout: 0
    });
    return defer.promise;
  }

  function queueSubmit(obj, timeout) {
    queue.add({
      condition: isRegistered,
      methods: ['sendObject'],
      params: [obj, timeout],
      defer: false,
      timeout: 0
    });
  }

  var on = function on(platform, type, func) {
    callbacks[type][platform] = func;
  };

  return {
    connect: connect,
    register: register,
    isConnected: isConnected,
    isRegistered: isRegistered,
    isConnecting: isConnecting,
    set: sendSet,
    submit: {
      call: callSubmit,
      queue: queueSubmit
    },
    on: on
  };
}]).


directive('sockethubSettings', ['SH', '$rootScope', 'SockethubSettings',
function (SH, $rootScope, settings) {
  return {
    restrict: 'A',
    template: '<div id="sockethubSettings" style="margin: 0 auto;" class="sockethub sockethub-form sockethub-settings">' +
              '  <div class="sockethub-logo" style="text-align:center;">' +
              '    <img data-ng-src="{{ sockethub.settings.env.logo }}" height="64" ng-cloak/>' +
              '  </div>' +
              '  <form name="settingsSockethub" role="form" class="form-horizontal" novalidate>' +
              '    <fieldset>' +
              '      <div class="form-group">' +
              '        <label for="host" class="col-sm-2 control-label">Hostname</label>' +
              '        <div class="controls">' +
              '          <input type="text" class="required form-control" name="host" placeholder="Enter hostname..." ng-model="sockethub.settings.conn.host" required>' +
              '        </div>' +
              '      </div>' +
              '      <div class="form-group">' +
              '        <label for="port" class="col-sm-2 control-label">Port</label>' +
              '        <div class="controls">' +
              '          <input type="text" class="required form-control" name="port" placeholder="Enter port..." ng-model="sockethub.settings.conn.port" required>' +
              '        </div>' +
              '      </div>' +
              '      <div class="form-group">' +
              '        <label for="path" class="col-sm-2 control-label">Path</label>' +
              '        <div class="controls">' +
              '          <input type="text" class="required form-control" name="path" placeholder="Enter path (if any)..." ng-model="sockethub.settings.conn.path">' +
              '        </div>' +
              '      </div>' +
              '      <div class="form-group">' +
              '        <div class="col-sm-offset-2 col-sm-10">' +
              '          <div class="checkbox">' +
              '            <label>' +
              '              <input type="checkbox" name="tls" ng-model="sockethub.settings.conn.tls"> TLS'+
              '            </label>' +
              '          </div>' +
              '        </div>' +
              '      </div>' +
              '      <div class="form-group">' +
              '        <label for="secret" class="col-sm-2 control-label">Secret</label>' +
              '        <div class="controls">' +
              '          <input type="text" class="required form-control" name="secret" placeholder="Enter secret..." ng-model="sockethub.settings.conn.secret" required>' +
              '        </div>' +
              '      </div>' +
              '    </fieldset>' +
              '    <div class="control-group">' +
              '      <div class="controls">' +
              '        <button class="btn btn-primary" ng-click="sockethub.save(sockethub.settings.conn)" ' +
              '                ng-disabled="!sockethub.settings.verify(\'conn\', sockethub.settings.conn) || saving">Submit</button>' +
              '      </div>' +
              '    </div>' +
              '  </form>' +
              '</div>',
    link: function (scope) {
      scope.sockethub = {
        saving: false,
        settings: settings
      };
      scope.sockethub.save = function (cfg) {
        scope.sockethub.saving = true;
        /*$rootScope.$broadcast('message', {
              type: 'clear'
        });*/
        scope.sockethub.settings.save('conn', cfg);
        $rootScope.$broadcast('message', {
              message: 'attempting to connect to sockethub',
              type: 'info',
              timeout: false
        });
        SH.connect({register: true}).then(function () {
          scope.sockethub.saving = false;
          console.log('connected to sockethub');
          $rootScope.$broadcast('message', {
                message: 'connected to sockethub',
                type: 'success',
                timeout: true
          });
          $rootScope.$broadcast('sockethubSettingsSaved');
        }, function (err) {
          scope.sockethub.saving = false;
          console.log('error connection to sockethub: ', err);
          $rootScope.$broadcast('message', {
                message: err,
                type: 'error',
                timeout: false
          });
        });
      };
    }
  };
}]);;angular.module('ngSockethubRemoteStorage', ['ngSockethubClient', 'ngRemoteStorage']).

/**
 * run
 */
run(['$rootScope', 'SockethubSettings', 'SH', 'RS',
function ($rootScope, settings, SH, RS) {
  //SH.on('sockethub', 'registered', function () {
  $rootScope.$on('sockethubSettingsSaved', function () {
    // sockethub connected, save settings to RS
    console.log('Sockethub-RemoteStorage: saving sockethub config to remoteStorage ', settings.conn);
    RS.call('sockethub', 'writeConfig', [settings.conn]).then(function () {
      console.log('config saved to RS');
    }, function (err) {
      console.log('Sockethub-RemoteStorage: Failed saving sockethub config to remoteStorage: ',err);
      $rootScope.$broadcast('message', {
        message: 'failed saving sockethub config to remote storage',
        type: 'error',
        timeout: true
      });
    });
  });
}]).

factory('SockethubBootstrap', ['RS', 'SockethubSettings', '$rootScope', 'SH', '$timeout',
function (RS, settings, $rootScope, SH, $timeout) {
  function run(defaultCfg) {

    function connect(cfg) {
      console.log('USING SH CONFIG: ', cfg);
      //$rootScope.$broadcast('message', {type: 'clear'});
      // connect to sockethub and register
      if (settings.save('conn', cfg)) {
        $rootScope.$broadcast('message', {
              message: 'attempting to connect to sockethub',
              type: 'info',
              timeout: false
        });
        SH.connect({register: true}).then(function () {
          //console.log('connected to sockethub');
          $rootScope.$broadcast('message', {
                message: 'connected to sockethub',
                type: 'success',
                timeout: true
          });
        }, function (err) {
          console.log('error connecting to sockethub: ', err);
          $rootScope.$broadcast('SockethubConnectFailed', {message: err});
        });
      } else {
        $rootScope.$broadcast('message', {
              message: 'failed saving sockethub credentials',
              type: 'error',
              timeout: true
        });
      }
    }

    RS.call('sockethub', 'getConfig', ['']).then(function (c) {
      console.log('GOT SH CONFIG: ', c);
      var cfg = {};
      if (!defaultCfg) {
        defaultCfg = {
          host: 'localhost',
          port: 10550,
          path: '/sockethub',
          tls: flse,
          secret: '1234567890'
        };
      }

      if ((typeof c !== 'object') || (typeof c.host !== 'string')) {
        //cfg = settings.conn;
        cfg = defaultCfg;
      } else {
        cfg = c;
      }
    }, function (err) {
      console.log("RS.call error: ",err);
    });

    $timeout(function () {
      connect(defaultCfg);
    }, 1000);
  }

  return {
    run: run
  };
}]);